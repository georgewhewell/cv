%\iffalse
% fmtcount.dtx generated using makedtx version 0.94b (c) Nicola Talbot
% Command line args:
%   -src "(.+)\.(sty)=>\1.\2"
%   -src "(.+)\.(def)=>\1.\2"
%   -doc "fmtcount-manual.tex"
%   -author "Nicola Talbot and Vincent Belaïche"
%   fmtcount
% Created on 2012/10/24 14:20
%\fi
%\iffalse
%<*package>
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
%</package>
%\fi
% \iffalse
% Doc-Source file to use with LaTeX2e
% Copyright (C) 2012 Nicola Talbot and Vincent Belaïche, all rights reserved.
% \fi
% \iffalse
%<*driver>
\documentclass{nlctdoc}

\usepackage{color}
\usepackage[utf8]{inputenc}
\usepackage[french,english]{babel}
\usepackage{amsmath,amssymb}
\usepackage{tabularx,supertabular,multirow}
\usepackage[T1]{fontenc}
\usepackage{cmap}
\newcommand*\uref[1]{\href{#1}{#1}}
\DeclareMathOperator{\intv}{..}
\newcommand*\interface{}
\usepackage[colorlinks,
            bookmarks,
            bookmarksopen,
            pdfauthor={Nicola L.C. Talbot},
            pdftitle={fmtcount.sty: Displaying the Values of LaTeX Counters},
            pdfkeywords={LaTeX,counter}]{hyperref}

\CheckSum{8940}

\doxitem{Option}{option}{options}

\newlength{\tabcolwidth}

\begin{document}
\DocInput{fmtcount.dtx}
\end{document}
%</driver>
%\fi
%\RecordChanges
%
% \title{fmtcount.sty: Displaying the Values of 
%\LaTeX\ Counters}
% \author{Nicola L.C. Talbot\\
% \url{www.dickimaw-books.com}
% \and
% Vincent Belaïche}
% \date{2012-10-24 (version 2.02)\relax
%}
% \maketitle
% \tableofcontents
% \section{Introduction}
%
%The \styfmt{fmtcount} package provides commands to display
%the values of \LaTeX\ counters in a variety of formats. It also
%provides equivalent commands for actual numbers rather than 
%counter names. Limited multilingual support is available. 
%Currently, there is only support for English, French (including
%Belgian and Swiss variations), Spanish, Portuguese, German and 
%Italian.
%
%\section{Available Commands}
%
%The commands can be divided into two categories: those that
%take the name of a counter as the argument, and those
%that take a number as the argument.
%
%\begin{definition}[\DescribeMacro{\ordinal}]
%\cs{ordinal}\marg{counter}\oarg{gender}
%\end{definition}
%This will print the value of a \LaTeX\ counter \meta{counter} as an 
%ordinal, where the macro
%\begin{definition}[\DescribeMacro{\fmtord}]
%\cs{fmtord}\marg{text}
%\end{definition}
%is used to format the st, nd, rd, th bit.  By default the ordinal is
%formatted as a superscript, if the package option \pkgopt{level} is
%used, it is level with the text.  For example, if the current section
%is 3, then \verb"\ordinal{section}" will produce the output:
%3\textsuperscript{rd}. Note that the optional argument \meta{gender} 
%occurs \emph{at the end}. This argument may only take one of
%the following values: \texttt{m} (masculine), \texttt{f}
%(feminine) or \texttt{n} (neuter.) If \meta{gender} is omitted, 
%or if the given gender has no meaning in the current language, 
%\texttt{m} is assumed.
%
%\textbf{Notes:} 
%\begin{enumerate}
%\item the \cls{memoir} class also defines a command called
%\cs{ordinal} which takes a number as an argument instead of a
%counter. In order to overcome this incompatiblity, if you want
%to use the \styfmt{fmtcount} package with the \cls{memoir} class 
%you should use
%\begin{definition}[\DescribeMacro{\FCordinal}]
%\cs{FCordinal}
%\end{definition}
%to access \styfmt{fmtcount}'s version of \cs{ordinal}, and use
%\cs{ordinal} to use \cls{memoir}'s version of that command.
%
%\item As with all commands which have an optional argument as the
%last argument, if the optional argument is omitted, any spaces
%following the final argument will be ignored. Whereas, if the
%optional argument is present, any spaces following the optional
%argument won't be ignored. so \verb"\ordinal{section} !"
%will produce: 3\textsuperscript{rd}! whereas
% \verb"\ordinal{section}[m] !" will produce:
%3\textsuperscript{rd} !
%\end{enumerate}
%
%The commands below only work for numbers in the range 0~to~99999.
%\begin{definition}[\DescribeMacro{\ordinalnum}]
%\cs{ordinalnum}\marg{n}\oarg{gender}
%\end{definition}
%This is like \cs{ordinal} but takes an actual number rather than a 
%counter as the argument. For example: \verb"\ordinalnum{3}" will
%produce: 3\textsuperscript{rd}.
%
%\begin{definition}[\DescribeMacro{\numberstring}]
%\cs{numberstring}\marg{counter}\oarg{gender}
%\end{definition}
%This will print the value of \meta{counter} as text.  E.g.\
%\verb"\numberstring{section}" will produce: three. The optional
%argument is the same as that for \cs{ordinal}.
%
%\begin{definition}[\DescribeMacro{\Numberstring}]
%\cs{Numberstring}\marg{counter}\oarg{gender}
%\end{definition}
%This does the same as \cs{numberstring}, but with initial letters in
%uppercase.  For example, \verb"\Numberstring{section}" will produce:
%Three.
%
%\begin{definition}[\DescribeMacro{\NUMBERstring}]
%\cs{NUMBERstring}\marg{counter}\oarg{gender}
%\end{definition}
%This does the same as \cs{numberstring}, but converts the string to
%upper case. Note that
%\verb"\MakeUppercase{\NUMBERstring{"\meta{counter}\verb'}}' doesn't
%work, due to the way that \cs{MakeUppercase} expands its
%argument\footnote{See all the various postings to
%\texttt{comp.text.tex} about \cs{MakeUppercase}}.
%
%\begin{definition}[\DescribeMacro{\numberstringnum}]
%\cs{numberstringnum}\marg{n}\oarg{gender}
%\end{definition}
%\begin{definition}[\DescribeMacro{\Numberstringnum}]
%\cs{Numberstringnum}\marg{n}\oarg{gender}
%\end{definition}
%\begin{definition}[\DescribeMacro{\NUMBERstringnum}]
%\cs{NUMBERstringnum}\marg{n}\oarg{gender}
%\end{definition}
%Theses macros  work like 
%\cs{numberstring}, \cs{Numberstring} and \cs{NUMBERstring}, 
%respectively, but take an actual number
%rather than a counter as the argument. For example:
%\verb'\Numberstringnum{105}' will produce: One Hundred and Five.
%
%\begin{definition}[\DescribeMacro{\ordinalstring}]
%\cs{ordinalstring}\marg{counter}\oarg{gender}
%\end{definition}
%This will print the value of \meta{counter} as a textual ordinal.
%E.g.\ \verb"\ordinalstring{section}" will produce: third. The
%optional argument is the same as that for \cs{ordinal}.
%
%\begin{definition}[\DescribeMacro{\Ordinalstring}]
%\cs{Ordinalstring}\marg{counter}\oarg{gender}
%\end{definition}
%This does the same as \cs{ordinalstring}, but with initial letters in
%uppercase.  For example, \verb"\Ordinalstring{section}" will produce:
%Third.
%
%\begin{definition}[\DescribeMacro{\ORDINALstring}]
%\cs{ORDINALstring}\marg{counter}\oarg{gender}
%\end{definition}
%This does the same as \cs{ordinalstring}, but with all words in upper
%case (see previous note about \cs{MakeUppercase}).
%
%\begin{definition}[\DescribeMacro{\ordinalstringnum}]
%\cs{ordinalstringnum}\marg{n}\oarg{gender}
%\end{definition}
%\begin{definition}[\DescribeMacro{\Ordinalstringnum}]
%\cs{Ordinalstringnum}\marg{n}\oarg{gender}
%\end{definition}
%\begin{definition}[\DescribeMacro{\ORDINALstringnum}]
%\cs{ORDINALstringnum}\marg{n}\oarg{gender}
%\end{definition}
%These macros work like \cs{ordinalstring}, \cs{Ordinalstring} and
%\cs{ORDINALstring}, respectively, but take an actual number rather
%than a counter as the argument. For example,
%\verb"\ordinalstringnum{3}" will produce: third.
%
%\changes{v.1.09}{21 Apr 2007}{store facility added}
%As from version 1.09, textual representations can be stored for
%later use. This overcomes the problems encountered when you
%attempt to use one of the above commands in \cs{edef}.
%
%Each of the following commands takes a label as the first argument,
%the other arguments are as the analogous commands above. These
%commands do not display anything, but store the textual 
%representation. This can later be retrieved using
%
%\begin{definition}[\DescribeMacro{\FMCuse}]
%\cs{FMCuse}\marg{label}
%\end{definition}
%
%\begin{important}
%Note: with \cs{storeordinal} and \cs{storeordinalnum}, the 
%only bit that doesn't get expanded is \cs{fmtord}. So, for 
%example, \verb"\storeordinalnum{mylabel}{3}" will be stored as
%\verb"3\relax \fmtord{rd}".
%\end{important}
%
%\begin{definition}[\DescribeMacro{\storeordinal}]
%\cs{storeordinal}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeordinalstring}]
%\cs{storeordinalstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeOrdinalstring}]
%\cs{storeOrdinalstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%
%\begin{definition}[\DescribeMacro{\storeORDINALstring}]
%\cs{storeORDINALstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storenumberstring}]
%\cs{storenumberstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeNumberstring}]
%\cs{storeNumberstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeNUMBERstring}]
%\cs{storeNUMBERstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeordinalnum}]
%\cs{storeordinalnum}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeordinalstringnum}]
%\cs{storeordinalstring}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeOrdinalstringnum}]
%\cs{storeOrdinalstringnum}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeORDINALstringnum}]
%\cs{storeORDINALstringnum}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storenumberstringnum}]
%\cs{storenumberstring}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeNumberstringnum}]
%\cs{storeNumberstring}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeNUMBERstringnum}]
%\cs{storeNUMBERstring}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\binary}]
%\cs{binary}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as a binary number.
%E.g.\ \verb"\binary{section}" will produce: 11. The declaration
%\begin{definition}[\DescribeMacro{\padzeroes}]
%\cs{padzeroes}\oarg{n}
%\end{definition}
%will ensure numbers are written to \meta{n} digits, padding with
%zeroes if necessary. E.g.\ \verb"\padzeroes[8]\binary{section}" will
%produce: 00000011. The default value for \meta{n} is 17.
%
%\begin{definition}[\DescribeMacro{\binarynum}]
%\cs{binary}\marg{n}
%\end{definition}
%This is like \cs{binary} but takes an actual number rather than a
%counter as the argument. For example: \verb"\binarynum{5}" will
%produce: 101.
%
%The octal commands only work for values in the range 0~to~32768.
%\begin{definition}[\DescribeMacro{\octal}]
%\cs{octal}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as an octal number.  For
%example, if you have a counter called, say \texttt{mycounter}, and
%you set the value to 125, then \verb"\octal{mycounter}" will produce:
%177.  Again, the number will be padded with zeroes if necessary,
%depending on whether \cs{padzeroes} has been used.
%
%\begin{definition}[\DescribeMacro{\octalnum}]
%\cs{octalnum}\marg{n}
%\end{definition}
%This is like \cs{octal} but takes an actual number rather than a
%counter as the argument. For example: \verb"\octalnum{125}" will
%produce: 177.
%
%\begin{definition}[\DescribeMacro{\hexadecimal}]
%\cs{hexadecimal}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as a hexadecimal number.
%Going back to the counter used in the previous example,
%\verb"\hexadecimal{mycounter}" will produce: 7d. Again, the number
%will be padded with zeroes if necessary, depending on whether
%\cs{padzeroes} has been used.
%
%\begin{definition}[\DescribeMacro{\Hexadecimal}]
%\cs{Hexadecimal}\marg{counter}
%\end{definition}
%This does the same thing, but uses uppercase characters, e.g.\
%\verb"\Hexadecimal{mycounter}" will produce: 7D.
%
%\begin{definition}[\DescribeMacro{\hexadecimalnum}]
%\cs{hexadecimalnum}\marg{n}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\Hexadecimalnum}]
%\cs{Hexadecimalnum}\marg{n}
%\end{definition}
%These are like \cs{hexadecimal} and \cs{Hexadecimal}
%but take an actual number rather than a counter as the
%argument. For example: \verb"\hexadecimalnum{125}" will
%produce: 7d, and \verb"\Hexadecimalnum{125}" will 
%produce: 7D.
%
%\begin{definition}[\DescribeMacro{\decimal}]
%\cs{decimal}\marg{counter}
%\end{definition}
%This is similar to \cs{arabic} but the number can be padded with
%zeroes depending on whether \cs{padzeroes} has been used.  For
%example: \verb"\padzeroes[8]\decimal{section}" will produce:
%00000005.
%
%\begin{definition}[\DescribeMacro{\decimalnum}]
%\cs{decimalnum}\marg{n}
%\end{definition}
%This is like \cs{decimal} but takes an actual number rather than a
%counter as the argument. For example:
%\verb"\padzeroes[8]\decimalnum{5}" will produce: 00000005.
%
%\begin{definition}[\DescribeMacro{\aaalph}]
%\cs{aaalph}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as: a b \ldots\ z aa bb
%\ldots\ zz etc.  For example, \verb"\aaalpha{mycounter}" will
%produce: uuuuu if \texttt{mycounter} is set to 125.
%
%\begin{definition}[\DescribeMacro{\AAAlph}]
%\cs{AAAlph}\marg{counter}
%\end{definition}
%This does the same thing, but uses uppercase characters, e.g.\
%\verb"\AAAlph{mycounter}" will produce: UUUUU.
%
%\begin{definition}[\DescribeMacro{\aaalphnum}]
%\cs{aaalphnum}\marg{n}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\AAAlphnum}]
%\cs{AAAlphnum}\marg{n}
%\end{definition}
%These macros are like \cs{aaalph} and \cs{AAAlph}
%but take an actual number rather than a counter as the
%argument. For example: \verb"\aaalphnum{125}" will
%produce: uuuuu, and \verb"\AAAlphnum{125}" will 
%produce: UUUUU.
%
%The abalph commands described below only work for values in the
%range 0~to~17576.
%\begin{definition}[\DescribeMacro{\abalph}]
%\cs{abalph}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as: a b \ldots\ z aa ab
%\ldots\ az etc.  For example, \verb"\abalpha{mycounter}" will
%produce: du if \texttt{mycounter} is set to 125.
%
%\begin{definition}[\DescribeMacro{\ABAlph}]
%\cs{ABAlph}\marg{counter}
%\end{definition}
%This does the same thing, but uses uppercase characters, e.g.\
%\verb"\ABAlph{mycounter}" will produce: DU.
%
%\begin{definition}[\DescribeMacro{\abalphnum}]
%\cs{abalphnum}\marg{n}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\ABAlphnum}]
%\cs{ABAlphnum}\marg{n}
%\end{definition}
%These macros are like \cs{abalph} and \cs{ABAlph}
%but take an actual number rather than a counter as the
%argument. For example: \verb"\abalphnum{125}" will
%produce: du, and \verb"\ABAlphnum{125}" will 
%produce: DU.
%
%\section{Package Options}
%
%The following options can be passed to this package:
%
%\begin{tabular}{ll}
% \pkgopt{raise}    & make ordinal st,nd,rd,th appear as superscript\\
% \pkgopt{level}    & make ordinal st,nd,rd,th appear level with rest of 
%text
%\end{tabular}
%
%\noindent These can also be set using the command:
%
%\begin{definition}[\DescribeMacro{\fmtcountsetoptions}]
%\cs{fmtcountsetoptions}\verb"{fmtord="\meta{type}\verb'}'
%\end{definition}
%where \meta{type} is either \texttt{level} or 
%\texttt{raise}.
%
%\section{Multilingual Support}
%
%Version 1.02 of the \sty{fmtcount} package now has
%limited multilingual support.  The following languages are
%implemented: English, Spanish, Portuguese, French, French (Swiss)
%and French (Belgian). German support was added in version 
%1.1.\footnote{Thanks to K. H. Fricke for supplying the information.}
%Italian support was added in version 1.31.\footnote{Thanks to
%Edoardo Pasca for supplying the information.}
%
%The package checks to see if the command \cs{l@}\meta{language} is
%defined\footnote{this will be true if you have loaded \sty{babel}},
%and will load the code for those languages.  The commands
%\cs{ordinal}, \cs{ordinalstring} and \cs{numberstring} (and their
%variants) will then be formatted in the currently selected language.
%
%If the French language is selected, the \texttt{french} option let you
%configure the dialect and other aspects. The \texttt{abbr} also has
%some influence with French. Please refer to \S~\ref
%{sec:options-french}.
%
%
%The male gender for all languages is used by default, however the
%feminine or neuter forms can be obtained by passing \texttt{f} or
%\texttt{n} as an optional argument to \cs{ordinal},
%\cs{ordinalnum} etc.  For example:
%\verb"\numberstring{section}[f]". Note that the optional argument
%comes \emph{after} the compulsory argument.  If a gender is
%not defined in a given language, the masculine version will
%be used instead.
%
%Let me know if you find any spelling mistakes (has been known
%to happen in English, let alone other languages with which I'm not so
%familiar.) If you want to add support for another language,
%you will need to let me know how to form the numbers and ordinals 
%from~0 to~99999 in that language for each gender.
%
%\subsection{Options for French}
%\label{sec:options-french}
%
%This section is in French, as it is most useful to French speaking people.
%
%\selectlanguage{french} Il est possible de configurer plusieurs
%aspects de la numérotation en français avec les options
%\texttt{french} et \texttt{abbr}. Ces options n'ont d'effet que si le
%langage \texttt{french} est chargé.
%
%\begin{definition}[\DescribeMacro{\fmtcountsetoptions}]
%\cs{fmtcountsetoptions}\verb"{french="\marg{french options}\verb'}'
%\end{definition}
%L'argument \meta{french options} est une liste entre accolades et
%séparée par des virgules de réglages de la forme
%``\meta{clef}\texttt{=}\meta{valeur}'', chacun de ces réglages est
%ci-après désigné par ``option française'' pour le distinguer des
%``options générales'' telles que \texttt{french}.
%
%Le dialecte peut être sélectionné avec l'option française
%\texttt{dialect} dont la valeur \meta{dialect} peut être
%\texttt{france}, \texttt{belgian} ou \texttt{swiss}.
%\begin{definition}[\DescribeOption{dialect}]
%\cs{fmtcountsetoptions}\verb"{french={dialect="\marg{dialect}\verb'}}'
%\end{definition}
%\begin{definition}[\DescribeOption{french}]
%\cs{fmtcountsetoptions}\verb"{french="\meta{dialect}\verb'}'
%\end{definition}
%
%Pour alléger la notation et par souci de rétro-compatibilité
%\texttt{france}, \texttt{belgian} ou \texttt{swiss} sont également des
%\meta{clef}s pour \meta{french options} à utiliser sans \meta{valeur}.
%
%L'effet de l'option \texttt{dialect} est illustré ainsi:\newline
%\begin{tabularx}{\linewidth}{@{}lX@{}}
%  \pkgopt{france}& soixante-dix pour 70, quatre-vingts pour 80, et
%  quate-vingts-dix pour 90,\\
%  \pkgopt{belgian} & septante pour 70, quatre-vingts pour 80, et
%  nonante pour 90, \\
%  \pkgopt{swiss} &septante pour 70, huitante\footnote{voir
%    \href{http://www.alain.be/Boece/huitante_octante.html}{Octante et
%      huitante} sur le site d'Alain Lassine} pour 80, et
%  nonante pour 90
%\end{tabularx}
%Il est à noter que la variante \texttt{belgian} est parfaitement
%correcte pour les francophones français\footnote{je précise que
%  l'auteur de ces lignes est français}, et qu'elle est également
%utilisée en Suisse Romande hormis dans les cantons de Vaud, du Valais
%et de Fribourg. En ce qui concerne le mot ``octante'', il n'est
%actuellement pas pris en charge et n'est guère plus utilisé, ce qui
%est sans doute dommage car il est sans doute plus acceptable que le
%``huitante'' de certains de nos amis suisses.
%
%\begin{definition}[\DescribeOption{abbr}]
%\cs{fmtcountsetoptions}\verb"{abbr="\meta{boolean}\verb'}'
%\end{definition}
%L'option générale \texttt{abbr} permet de changer l'effet de
%\cs{ordinal}. Selon \meta{boolean} on a:\newline
%\begin{tabularx}{\linewidth}{@{}lX@{}}
%  \pkgopt{true}& pour produire des ordinaux de la forme
%  2\textsuperscript{e}, ou\\
%  \pkgopt{false}& pour produire des ordinaux de la forme
%  2\textsuperscript{eme} (par defaut)\\
%\end{tabularx}
%
%\begin{definition}[\DescribeOption{vingt plural}]
%\cs{fmtcountsetoptions}\verb"{french={vingt plural="\meta{french plural control}\verb'}}'
%\end{definition}
%\begin{definition}[\DescribeOption{cent plural}]
%\cs{fmtcountsetoptions}\verb"{french={cent plural="\meta{french plural control}\verb'}}'
%\end{definition}
%\begin{definition}[\DescribeOption{mil plural}]
%\cs{fmtcountsetoptions}\verb"{french={mil plural="\meta{french plural control}\verb'}}'
%\end{definition}
%\begin{definition}[\DescribeOption{n-illion plural}]
%\cs{fmtcountsetoptions}\verb"{french={n-illion plural="\meta{french plural control}\verb'}}'
%\end{definition}
%\begin{definition}[\DescribeOption{n-illiard plural}]
%\cs{fmtcountsetoptions}\verb"{french={n-illiard plural="\meta{french plural control}\verb'}}'
%\end{definition}
%\begin{definition}[\DescribeOption{all plural}]
%\cs{fmtcountsetoptions}\verb"{french={all plural="\meta{french plural control}\verb'}}'
%\end{definition}
%Les options \texttt{vingt plural}, \texttt{cent plural}, \texttt{mil plural}, \texttt{n-illion plural}, et
%\texttt{n-illiard plural}, permettent de contrôler très finement l'accord en nombre des mots respectivement
%vingt, cent, mil, et des mots de la forme \meta{\(n\)}illion et \meta{\(n\)}illiard, où \meta{\(n\)} désigne
%`m' pour 1, `b' pour 2, 'tr' pour 3, etc. L'option \texttt{all plural} est un raccourci permettant de
%contrôler de concert l'accord en nombre de tous ces mots. Tous ces paramètres valent \texttt{reformed} par
%défaut.
%
%Attention, comme on va l'expliquer, seules quelques combinaisons de configurations de ces options donnent un
%orthographe correcte vis à vis des règles en vigueur. La raison d'être de ces options est la suivante~:
%\begin{itemize}
%\item la règle de l'accord en nombre des noms de nombre dans un numéral cardinal dépend de savoir s'il a
%  vraiment une valeur cardinale ou bien une valeur ordinale, ainsi on écrit \og aller à la page deux-cent
%  (sans s) d'un livre de deux-cents (avec s) pages\fg, il faut donc pouvoir changer la configuration pour
%  sélectionner le cas considéré,
%\item un autre cas demandant quelque configurabilité est celui de \og mil\fg\ et \og mille\fg. Pour rappel \og
%  mille\fg\ est le pluriel irrégulier de \og mil\fg, mais l'alternance mil/mille est rare, voire pédante, car
%  aujourd'hui \og mille\fg\ n'est utilisé que comme un mot invariable, en effet le sort des pluriels étrangers
%  est systématiquement de finir par disparaître comme par exemple \og scénarii\fg\ aujourd'hui supplanté par
%  \og scénarios\fg. Pour continuer à pouvoir écrire \og mil\fg, il aurait fallu former le pluriel comme \og
%  mils\fg, ce qui n'est pas l'usage.  Certaines personnes utilisent toutefois encore \og mil\fg\ dans les
%  dates, par exemple \og mil neuf cent quatre-vingt quatre\fg\ au lieu de \og mille neuf cent quatre-vingt
%  quatre\fg,
%\item finalement les règles du français quoique bien définies ne sont pas très cohérentes et il est donc
%  inévitable qu'un jour ou l'autre on on les simplifie. Le paquetage \styfmt{fmtcount} est déjà prêt à cette
%  éventualité.
%\end{itemize}
%
%Le paramètre \meta{french plural control} peut prendre les valeurs suivantes:\newline
%\settowidth{\tabcolwidth}{\pkgopt{multiple lng-width}}
%\begin{supertabular}{@{}p{\tabcolwidth}p{\dimexpr\linewidth-\tabcolwidth-2\tabcolsep}@{}}
%  \pkgopt{traditional}& pour sélectionner la règle en usage chez les adultes à la date de parution de ce
%  document, et dans le cas des numéraux cardinaux, lorsqu'ils ont une valeur cardinale,\\
%  \pkgopt{reformed}& pour suivre toute nouvelle recommandation à la date de parution de ce document, , et
%  dans le cas des numéraux cardinaux, lorsqu'ils ont une valeur cardinale, l'idée des options
%  \texttt{traditional} et \texttt{reformed} est donc de pouvoir contenter à la fois les anciens et les
%  modernes, mais à dire vrai à la date où ce document est écrit elles ont exactement
%  le même effet,\\
%  \pkgopt{traditional o}& pareil que \texttt{traditional} mais dans le cas des numéraux cardinaux,
%  lorsqu'ils
%  ont une valeur ordinale,\\
%  \pkgopt{reformed o}& pareil que \texttt{reformed} mais dans le cas des numéraux cardinaux, lorsqu'ils ont
%  une valeur ordinale, de même que précédemment \texttt{reformed o} et \texttt{traditional o} ont
%  exactement le même effet,\\
%  \pkgopt{always}& pour marquer toujours le pluriel, ceci n'est correct que pour \og mil\fg\ vis à vis des
%  règles en vigueur,\\
%  \pkgopt{never}& pour ne jamais marquer le pluriel, ceci est incorrect vis à vis des règles d'orthographe
%  en vigueur,\\
%  \pkgopt{multiple}& pour marquer le pluriel lorsque le nombre considéré est multiplié par au moins 2, ceci
%  est la règle en vigueur pour les nombres de la forme \meta{\(n\)}illion et \meta{\(n\)}illiard lorsque le
%  nombre a une valeur cardinale,\\
%  \pkgopt{multiple g-last}& pour marquer le pluriel lorsque le nombre considéré est multiplié par au moins 2
%  est est \emph{\textbf{g}lobalement} en dernière position, où ``globalement'' signifie qu'on considère le
%  nombre formaté en entier, ceci est incorrect vis à vis des règles d'orthographe
%  en vigueur,\\
%  \pkgopt{multiple l-last}& pour marquer le pluriel lorsque le nombre considéré est multiplié par au moins 2
%  et est \emph{\textbf{l}ocalement} en dernière position, où ``localement'' siginifie qu'on considère
%  seulement la portion du nombre qui multiplie soit l'unité, soit un \meta{\(n\)}illion ou un
%  \meta{\(n\)}illiard~; ceci est la convention en vigueur pour le pluriel de ``vingt'' et de ``cent''
%  lorsque le nombre formaté a une valeur cardinale,\\
%  \pkgopt{multiple lng-last}& pour marquer le pluriel lorsque le nombre considéré est multiplié par au moins
%  2 et est \emph{\textbf{l}ocalement} mais \emph{\textbf{n}on \textbf{g}lobablement} en dernière position,
%  où ``localement'' et \emph{globablement} on la même siginification que pour les options \texttt{multiple
%    g-last} et \texttt{multiple l-last}~; ceci est la convention en vigueur pour le pluriel de ``vingt'' et
%  de ``cent'' lorsque le nombre formaté a une valeur ordinale,\\
%  \pkgopt{multiple ng-last}& pour marquer le pluriel lorsque le nombre considéré est multiplié par au moins
%  2, et \emph{\textbf{n}}'est pas \emph{\textbf{g}lobalement} en dernière position, où ``globalement'' a la
%  même signification que pour l'option \texttt{multiple g-last}~; ceci est la règle que j'infère être en
%  vigueur pour les nombres de la forme \meta{\(n\)}illion et \meta{\(n\)}illiard lorsque le nombre a une
%  valeur ordinale, mais à dire vrai pour des nombres aussi grands, par exemple \og deux millions\fg, je
%  pense qu'il n'est tout simplement pas d'usage de dire \og l'exemplaire deux million(s?)\fg\ pour \og le
%  deux millionième
%  exemplaire\fg.\\
%\end{supertabular}
%
%L'effet des paramètres \texttt{traditional}, \texttt{traditional o}, \texttt{reformed}, et \texttt{reformed
%  o}, est le suivant~:
%
%\setlength{\tabcolwidth}{\linewidth}
%\addtolength{\tabcolwidth}{-10\tabcolsep}
%\addtolength{\tabcolwidth}{-6\arrayrulewidth}
%\noindent\begin{tabular*}{\linewidth}{|%
%    >{\centering\arraybackslash\ttfamily}p{\dimexpr0.204\tabcolwidth-\arrayrulewidth-\doublerulesep}||%
%    *{4}{>{\centering\arraybackslash\ttfamily}p{0.199\tabcolwidth}|}}\hline
%  \textrm{\meta{x} dans ``\meta{x} }plural\textrm{''}&traditional&reformed&traditional o&reformed o\\\hline
%  \hline
%  vingt&\multicolumn{2}{c|}{}&\multicolumn{2}{c|}{}\\\cline{1-1}
%  cent&%
%  \multicolumn{2}{c|}{\multirow{-2}{\dimexpr0.398\tabcolwidth+\arrayrulewidth+2\tabcolsep}{\centering 
%      multiple l-last}}&%
%  \multicolumn{2}{c|}{\multirow{-2}{\dimexpr0.398\tabcolwidth+\arrayrulewidth+2\tabcolsep}{\centering 
%      multiple lng-last}}\\\hline
%  mil&\multicolumn{4}{c|}{always}\\\hline
%  n-illion&\multicolumn{2}{c|}{}&\multicolumn{2}{c|}{}\\\cline{1-1}
%  n-illiard&%
%  \multicolumn{2}{c|}{\multirow{-2}{\dimexpr0.398\tabcolwidth+\arrayrulewidth+2\tabcolsep}{\centering 
%      multiple}}&%
%  \multicolumn{2}{c|}{\multirow{-2}{\dimexpr0.398\tabcolwidth+\arrayrulewidth+2\tabcolsep}{\centering 
%      multiple ng-last}}\\\hline
%\end{tabular*}
%
%Les configurations qui respectent les règles d'orthographe sont les suivantes~:
%\begin{itemize}
%\item \verb"\fmtcountsetoptions{french={all plural=reformed o}}" pour formater les numéraux cardinaux à
%  valeur ordinale,
%\item \verb"\fmtcountsetoptions{french={mil plural=multiple}}" pour activer l'alternance mil/mille.
%\item \verb"\fmtcountsetoptions{french={all plural=reformed}}" pour revenir dans la configuration par
%  défaut.
%\end{itemize}
%
%\begin{definition}[\DescribeOption{dash or space}]
%\cs{fmtcountsetoptions}\verb"{french={dash or space="\meta{dash or space}\verb'}}'
%\end{definition}
%Avant la réforme de l'orthographe de 1990, on ne met des traits d'union qu'entre les dizaines et les unités,
%et encore sauf quand le nombre \(n\) considéré est tel que \(n\mod10=1\), dans ce cas on écrit ``et un''
%sans trait d'union. Après la réforme de 1990, on recommande de mettre des traits d'union de partout sauf
%autour de ``mille'', ``million'' et ``milliard'', et les mots analogues comme ``billion'',
%``billiard''. Cette exception a toutefois été contestée par de nombreux auteurs, et on peut aussi mettre des
%traits d'union de partout.  Mettre l'option \meta{dash or space} à:\newline
%\begin{tabularx}{\linewidth}{lX}
%  \pkgopt{traditional}&  pour sélectionner la règle d'avant la réforme de 1990,\\
%  \pkgopt{1990}&  pour suivre  la recommandation de la réforme de 1990, \\
%  \pkgopt{reformed}&  pour suivre  la recommandation de la dernière
%  réforme pise en charge, actuellement l'effet est le même que \textrm{1990}, ou à\\
%  \pkgopt{always}&  pour mettre systématiquement des traits d'union de partout.\\
%\end{tabularx}
%Par défaut, l'option vaut \texttt{reformed}.
%
%
%\begin{definition}[\DescribeOption{scale}]
%\cs{fmtcountsetoptions}\verb"{french={scale="\meta{scale}\verb'}}'
%\end{definition}
%L'option \texttt{scale} permet de configurer l'écriture des grands
%nombres. Mettre \meta{scale} à:\newline
%\begin{tabularx}{\linewidth}{lX}
%  \pkgopt{recursive}&  dans ce cas \(10^{30}\) donne mille milliards de
%  milliards de milliards, pour \(10^n\), on écrit \(10^{n-9\times
%    \max\{(n\div 9)-1,0\}}\) suivi de la répétition \(\max\{(n\div
%  9)-1,0\}\) fois de ``de milliards''\\
%  \pkgopt{long}&  \(10^{6\times n}\) donne un \meta{\(n\)}illion où
%  \meta{\(n\)} est remplacé par ``bi'' pour 2, ``tri'' pour 3, etc. et
%  \(10^{6\times n+3}\) donne un \meta{\(n\)}illiard avec la même
%  convention pour \meta{\(n\)}. L'option \texttt{long} est correcte en
%  Europe, par contre j'ignore l'usage au
%  Québec.\\
%  \pkgopt{short}&  \(10^{6\times n}\) donne un \meta{\(n\)}illion où
%  \meta{\(n\)} est remplacé par ``bi'' pour 2, ``tri'' pour 3,
%  etc. L'option \texttt{short} est incorrecte en Europe.
%\end{tabularx}
%Par défaut, l'option vaut \texttt{recursive}.
%
%\begin{definition}[\DescribeOption{n-illiard upto}]
%\cs{fmtcountsetoptions}\verb"{french={n-illiard upto="\meta{n-illiard upto}\verb'}}'
%\end{definition}
%Cette option n'a de sens que si \texttt{scale} vaut
%\texttt{long}. Certaines personnes préfèrent dire ``mille
%\meta{$n$}illions'' qu'un ``\meta{$n$}illiard''. Mettre l'option
%\texttt{n-illiard upto} à:\newline
%\begin{tabularx}{\linewidth}{lX}
%  \pkgopt{infinity}&  pour que \(10^{6\times n +3}\) donne
%  \meta{$n$}illiards pour tout \(n>0\),\\
%  \pkgopt{infty}&  même effet que \texttt{infinity}, \\
%  \(k\)&  où \(k\) est un entier quelconque strictement positif, dans
%  ce cas \(10^{6\times n +3}\) donne ``mille \meta{\(n\)}illions''
%  lorsque \(n>k\), et donne ``\meta{\(n\)}illiard'' sinon\\
%\end{tabularx}
%
%\begin{definition}[\DescribeOption{mil plural mark}]
%\cs{fmtcountsetoptions}\verb"{french={mil plural mark="\meta{any text}\verb'}}'
%\end{definition}
%La valeur par défaut de cette option est \og\texttt{le}\fg. Il s'agit de la terminaison ajoutée à \og
%mil\fg\ pour former le pluriel, c'est à dire \og mille\fg, cette option ne sert pas à grand chose sauf dans
%l'éventualité où ce pluriel serait francisé un jour --- à dire vrai si cela se produisait une alternance
%mille/milles est plus vraisemblable, car \og mille\fg\ est plus fréquent que \og mille\fg\ et que les
%pluriels francisés sont formés en ajoutant \og s\fg\ à la forme la plus fréquente, par exemple \og
%blini/blinis\fg, alors que \og blini\fg\ veut dire \og crêpes\fg\ (au pluriel).
%
%
%\selectlanguage{english}
%
%%\subsection{Prefixes}
%%\label{sec:latin-prefixes}
%%
%%\begin{definition}[\DescribeMacro{\latinnumeralstring}]
%%\cs{latinnumeralstring}\marg{counter}\oarg{prefix options}
%%\end{definition}
%%
%%\begin{definition}[\DescribeMacro{\latinnumeralstringnum}]
%%\cs{latinnumeralstringnum}\marg{number}\oarg{prefix options}
%%\end{definition}
%
%
%\section{Configuration File \texttt{fmtcount.cfg}}
%
%You can save your preferred default settings to a file called
%\texttt{fmtcount.cfg}, and place it on the \TeX\ path.  These
%settings will then be loaded by the \sty{fmtcount}
%package.
%
%Note that if you are using the \sty{datetime} package,
%the \texttt{datetime.cfg} configuration file will override
%the \texttt{fmtcount.cfg} configuration file.
%For example, if \texttt{datetime.cfg} has the line:
%\begin{verbatim}
%\renewcommand{\fmtord}[1]{\textsuperscript{\underline{#1}}}
%\end{verbatim}
%and if \texttt{fmtcount.cfg} has the line:
%\begin{verbatim}
%\fmtcountsetoptions{fmtord=level}
%\end{verbatim}
%then the former definition of \cs{fmtord} will take
%precedence.
%
%\section{LaTeX2HTML style}
%
%The \LaTeX2HTML\ style file \texttt{fmtcount.perl} is provided.
%The following limitations apply:
%
%\begin{itemize}
%\item \cs{padzeroes} only has an effect in the preamble.
%
%\item The configuration file 
%\texttt{fmtcount.cfg} is currently ignored. (This is because
%I can't work out the correct code to do this.  If you
%know how to do this, please let me know.)  You can however
%do:
%\begin{verbatim}
%\usepackage{fmtcount}
%\html{\input{fmtcount.cfg}}
%\end{verbatim}
%This, I agree, is an unpleasant cludge.
%
%\end{itemize}
%
%\section{Acknowledgements}
%
%I would like to thank all the people who have provided translations.
%
%\section{Troubleshooting}
%
%There is a FAQ available at: 
%\url{http://theoval.cmp.uea.ac.uk/~nlct/latex/packages/faq/}.
%
%
%
%\StopEventually{}
%\section{The Code}
%\iffalse
%    \begin{macrocode}
%<*fcnumparser.sty>
%    \end{macrocode}
%\fi
%\subsection{fcnumparser.sty}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{fcnumparser}[2012/09/28]
%    \end{macrocode}
% \cs{fc@counter@parser} is just a shorthand to parse a number held in a counter.
%    \begin{macrocode}
\def\fc@counter@parser#1{%
  \expandafter\fc@number@parser\expandafter{\the#1.}%
}
%    \end{macrocode}
%    \begin{macrocode}
\newcount\fc@digit@counter

\def\fc@end@{\fc@end}
%    \end{macrocode}
% \DescribeMacro\fc@number@analysis First of all we need to separate the number between integer and fractional
% part. Number to be analysed is in `\texttt{\#1}'. Decimal separator may be . or , whichever first. At end of
% this macro, integer part goes to \cs{fc@integer@part} and fractional part goes to \cs{fc@fractional@part}.
%    \begin{macrocode}
\def\fc@number@analysis#1\fc@nil{%
%    \end{macrocode}
% First check for the presence of a decimal point in the number.
%    \begin{macrocode}
  \def\@tempb##1.##2\fc@nil{\def\fc@integer@part{##1}\def\@tempa{##2}}%
  \@tempb#1.\fc@end\fc@nil
  \ifx\@tempa\fc@end@
%    \end{macrocode}
% Here \cs{@tempa} is \cs{ifx}-equal to \cs{fc@end}, which means that the number does not contain any decimal
% point. So we do the same trick to search for a comma.
%    \begin{macrocode}
    \def\@tempb##1,##2\fc@nil{\def\fc@integer@part{##1}\def\@tempa{##2}}%
    \@tempb#1,\fc@end\fc@nil
    \ifx\@tempa\fc@end@
%    \end{macrocode}
% No comma either, so fractional part is set empty.
%    \begin{macrocode}
       \def\fc@fractional@part{}%
    \else
%    \end{macrocode}
% Comma has been found, so we just need to drop `\texttt{,}\cs{fc@end}' from the end of \cs{@tempa} to get the
% fractional part.
%    \begin{macrocode}
       \def\@tempb##1,\fc@end{\def\fc@fractional@part{##1}}%
       \expandafter\@tempb\@tempa
    \fi
  \else
%    \end{macrocode}
% Decimal point has been found, so we just need to drop `\texttt{.}\cs{fc@end}' from the end \cs{@tempa} to
% get the fractional part.
%    \begin{macrocode}
       \def\@tempb##1.\fc@end{\def\fc@fractional@part{##1}}%
       \expandafter\@tempb\@tempa
  \fi
}
%    \end{macrocode}
% \DescribeMacro\fc@number@parser Macro \cs{fc@number@parser} is the main engine to parse a number.  Argument
% `\#1' is input and contains the number to be parsed. At end of this macro, each digit is stored separately
% in a \cs{fc@digit@}\meta{$n$}, and macros \cs{fc@min@weight} and \cs{fc@max@weight} are set to the bounds
% for \meta{$n$}.
%    \begin{macrocode}
\def\fc@number@parser#1{%
%    \end{macrocode}
% First remove all the spaces in \texttt{\#1}, and place the result into \cs{@tempa}.
%    \begin{macrocode}
  \let\@tempa\@empty
  \def\@tempb##1##2\fc@nil{%
    \def\@tempc{##1}%
    \ifx\@tempc\space
    \else
      \expandafter\def\expandafter\@tempa\expandafter{\@tempa ##1}%
    \fi
    \def\@tempc{##2}%
    \ifx\@tempc\@empty
      \expandafter\@gobble
    \else
      \expandafter\@tempb
    \fi
    ##2\fc@nil
  }%
  \@tempb#1\fc@nil
%    \end{macrocode}
% Get the sign into \cs{fc@sign} and the unsigned number part into \cs{fc@number}.
%    \begin{macrocode}
  \def\@tempb##1##2\fc@nil{\def\fc@sign{##1}\def\fc@number{##2}}%
  \expandafter\@tempb\@tempa\fc@nil
  \expandafter\if\fc@sign+%
    \def\fc@sign@case{1}%
  \else
    \expandafter\if\fc@sign-%
      \def\fc@sign@case{2}%
    \else
      \def\fc@sign{}%
      \def\fc@sign@case{0}%
      \let\fc@number\@tempa
    \fi
  \fi
  \ifx\fc@number\@empty
    \PackageError{fcnumparser}{Invalid number}{Number must contain at least one non blank
      character after sign}%
  \fi
%    \end{macrocode}
% Now, split \cs{fc@number} into \cs{fc@integer@part} and \cs{fc@fractional@part}.
%    \begin{macrocode}
  \expandafter\fc@number@analysis\fc@number\fc@nil
%    \end{macrocode}
% Now, split \cs{fc@integer@part} into a sequence of \cs{fc@digit@}\meta{$n$} with \meta{$n$} ranging from
% \cs{fc@unit@weight} to \cs{fc@max@weight}. We will use macro \cs{fc@parse@integer@digits} for that, but that
% will place the digits into \cs{fc@digit@}\meta{$n$} with \meta{$n$} ranging from
% \(2\times\cs{fc@unit@weight}-\cs{fc@max@weight}\) upto \(\cs{fc@unit@weight}-1\).
%    \begin{macrocode}
  \expandafter\fc@digit@counter\fc@unit@weight
  \expandafter\fc@parse@integer@digits\fc@integer@part\fc@end\fc@nil
%    \end{macrocode}
% First we compute the weight of the most significant digit: after \cs{fc@parse@integer@digits},
% \cs{fc@digit@counter} is equal to \(\cs{fc@unit@weight} -\mathrm{mw} -1\) and we want to set
% \cs{fc@max@weight} to \(\cs{fc@unit@weight} +\mathrm{mw}\) so we do:
% \begin{equation*}
% \cs{fc@max@weight}\leftarrow (-\cs{fc@digit@counter}) + 2\times\cs{fc@unit@weight} -1
% \end{equation*}
%    \begin{macrocode}
  \fc@digit@counter -\fc@digit@counter
  \advance\fc@digit@counter by \fc@unit@weight
  \advance\fc@digit@counter by \fc@unit@weight
  \advance\fc@digit@counter by -1 %
  \edef\fc@max@weight{\the\fc@digit@counter}%
%    \end{macrocode}
% Now we loop for \(i = \cs{fc@unit@weight}\) to \cs{fc@max@weight} in order to copy all the digits from
% \cs{fc@digit@}\meta{\(i + \mathrm{offset}\)} to \cs{fc@digit@}\meta{\(i\)}. First we compute
% \(\mathrm{offset}\) into \cs{@tempi}.
%    \begin{macrocode}
  {%
    \count0 \fc@unit@weight\relax
    \count1 \fc@max@weight\relax
    \advance\count0 by -\count1 %
    \advance\count0 by -1 %
    \def\@tempa##1{\def\@tempb{\def\@tempi{##1}}}%
    \expandafter\@tempa\expandafter{\the\count0}%
    \expandafter
  }\@tempb
%    \end{macrocode}
% Now we loop to copy the digits. To do that we define a macro \cs{@templ} for terminal recursion.
%    \begin{macrocode}
  \expandafter\fc@digit@counter\fc@unit@weight
  \def\@templ{%
     \ifnum\fc@digit@counter>\fc@max@weight
        \let\next\relax
     \else
%    \end{macrocode}
% Here is the loop body:
%    \begin{macrocode}
        {%
          \count0 \@tempi
          \advance\count0 by \fc@digit@counter
          \expandafter\def\expandafter\@tempd\expandafter{\csname fc@digit@\the\count0\endcsname}%
          \expandafter\def\expandafter\@tempe\expandafter{\csname fc@digit@\the\fc@digit@counter\endcsname}%
          \def\@tempa####1####2{\def\@tempb{\let####1####2}}%
          \expandafter\expandafter\expandafter\@tempa\expandafter\@tempe\@tempd
          \expandafter
        }\@tempb
        \advance\fc@digit@counter by 1 %
     \fi
     \next
  }%
  \let\next\@templ
  \@templ
%    \end{macrocode}
% Split \cs{fc@fractional@part} into a sequence of \cs{fc@digit@}\meta{$n$} with \meta{$n$} ranging from
% \(\cs{fc@unit@weight}-1\) to \cs{fc@min@weight} by step of \(-1\). This is much more simpler because we get
% the digits with the final range of index, so no post-processing loop is needed.
%    \begin{macrocode}
  \expandafter\fc@digit@counter\fc@unit@weight
  \expandafter\fc@parse@integer@digits\fc@fractional@part\fc@end\fc@nil
  \edef\fc@min@weight{\the\fc@digit@counter}%
}
%    \end{macrocode}
% \DescribeMacro\fc@parse@integer@digits Macro \cs{fc@parse@integer@digits} is used to 
%    \begin{macrocode}
\@ifundefined{fc@parse@integer@digits}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of 
    macro `fc@parse@integer@digits'}}
\def\fc@parse@integer@digits#1#2\fc@nil{%
  \def\@tempa{#1}%
  \ifx\@tempa\fc@end@
     \def\next##1\fc@nil{}%
  \else
  \let\next\fc@parse@integer@digits
  \advance\fc@digit@counter by -1
  \expandafter\def\csname fc@digit@\the\fc@digit@counter\endcsname{#1}%
  \fi
  \next#2\fc@nil
}


\newcommand*{\fc@unit@weight}{0}

%    \end{macrocode}
% Now we have macros to read a few digits from the \cs{fc@digit@}\meta{$n$} array and form a correspoding
% number.\newline \DescribeMacro\fc@read@unit \cs{fc@read@unit} just reads one digit and form an integer in
% the range \([0 \intv 9]\). First we check that the macro is not yet defined.
%    \begin{macrocode}
\@ifundefined{fc@read@unit}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of macro `fc@read@unit'}}
%    \end{macrocode}
% Arguments as follows:\def\interface{\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&output counter: into which the read value is placed\\
% \#2&input number: unit weight at which reach the value is to be read
% \end{tabularx}}\interface
% \#2 does not need to be comprised between \cs{fc@min@weight} and {fc@min@weight}, if outside this interval,
% then a zero is read.
%    \begin{macrocode}
\def\fc@read@unit#1#2{%
  \ifnum#2>\fc@max@weight
     #1=0\relax
  \else
     \ifnum#2<\fc@min@weight
        #1=0\relax
     \else
         {%
           \edef\@tempa{\number#2}%
           \count0=\@tempa
           \edef\@tempa{\csname fc@digit@\the\count0\endcsname}%
           \def\@tempb##1{\def\@tempa{#1=##1\relax}}%
           \expandafter\@tempb\expandafter{\@tempa}%
           \expandafter
         }\@tempa
     \fi
  \fi
}
%    \end{macrocode}
% \DescribeMacro\fc@read@hundred Macro \cs{fc@read@hundred} is used to read a pair of digits and form an
% integer in the range \([0 \intv 99]\).  First we check that the macro is not yet defined.
%    \begin{macrocode}
\@ifundefined{fc@read@hundred}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of macro `fc@read@hundred'}}
%    \end{macrocode}
% Arguments as follows --- same interface as \cs{fc@read@unit}:\interface
%    \begin{macrocode}
\def\fc@read@hundred#1#2{%
  {%
    \fc@read@unit{\count0}{#2}%
    \def\@tempa##1{\fc@read@unit{\count1}{##1}}%
    \count2=#2%
    \advance\count2 by 1 %
    \expandafter\@tempa{\the\count2}%
    \multiply\count1 by 10 %
    \advance\count1 by \count0 %
    \def\@tempa##1{\def\@tempb{#1=##1\relax}}
    \expandafter\@tempa\expandafter{\the\count1}%
    \expandafter
  }\@tempb
}
%    \end{macrocode}
% \DescribeMacro\fc@read@thousand Macro \cs{fc@read@thousand} is used to read a trio of digits and form an
% integer in the range \([0 \intv 999]\).  First we check that the macro is not yet defined.
%    \begin{macrocode}
\@ifundefined{fc@read@thousand}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of macro
    `fc@read@thousand'}}
%    \end{macrocode}
% Arguments as follows --- same interface as \cs{fc@read@unit}:\interface
%    \begin{macrocode}
\def\fc@read@thousand#1#2{%
  {%
    \fc@read@unit{\count0}{#2}%
    \def\@tempa##1{\fc@read@hundred{\count1}{##1}}%
    \count2=#2%
    \advance\count2 by 1 %
    \expandafter\@tempa{\the\count2}%
    \multiply\count1 by 10 %
    \advance\count1 by \count0 %
    \def\@tempa##1{\def\@tempb{#1=##1\relax}}
    \expandafter\@tempa\expandafter{\the\count1}%
    \expandafter
  }\@tempb
}
%    \end{macrocode}
% Note: one myriad is ten thousand.
% \DescribeMacro\fc@read@thousand Macro \cs{fc@read@myriad} is used to read a quatuor of digits and form an
% integer in the range \([0 \intv 9999]\).  First we check that the macro is not yet defined.
%    \begin{macrocode}
\@ifundefined{fc@read@myriad}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of macro
    `fc@read@myriad'}}
%    \end{macrocode}
% Arguments as follows --- same interface as \cs{fc@read@unit}:\interface
%    \begin{macrocode}
\def\fc@read@myriad#1#2{%
  {%
    \fc@read@hundred{\count0}{#2}%
    \def\@tempa##1{\fc@read@hundred{\count1}{##1}}%
    \count2=#2
    \advance\count2 by 2
    \expandafter\@tempa{\the\count2}%
    \multiply\count1 by 100 %
    \advance\count1 by \count0 %
    \def\@tempa##1{\def\@tempb{#1=##1\relax}}%
    \expandafter\@tempa\expandafter{\the\count1}%
    \expandafter
  }\@tempb
}
%    \end{macrocode}
% \DescribeMacro\fc@check@nonzeros Macro \cs{fc@check@nonzeros} is used to check whether the number
% represented by digits \cs{fc@digit@}\meta{$n$}, with \(n\) in some interval, is zero, one, or more than one.
% First we check that the macro is not yet defined.
%    \begin{macrocode}
\@ifundefined{fc@check@nonzeros}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of macro
    `fc@check@nonzeros'}}
%    \end{macrocode}
% Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#1&input number: minimum unit unit weight at which start to search the non-zeros\\
%   \#2&input number: maximum unit weight at which end to seach the non-zeros\\
%   \#3&output macro: let \(n\) be the number represented by digits the weight of which span from \texttt{\#1}
%   to \texttt{\#2}, then \texttt{\#3} is set to the number min(n,9).\\
% \end{tabularx}
% Actually \cs{fc@check@nonzeros} is just a wrapper to collect arguments, and the real job is delegated to
% \cs{fc@@check@nonzeros@inner} which is called inside a group. 
%    \begin{macrocode}
\def\fc@check@nonzeros#1#2#3{%
  {%
%    \end{macrocode}
% So first we save inputs into local macros used by \cs{fc@@check@nonzeros@inner} as input arguments
%    \begin{macrocode}
    \edef\@@tempa{\number#1}%
    \edef\@tempb{\number#2}%
    \count0=\@@tempa
    \count1=\@tempb\relax
%    \end{macrocode}
% Then we do the real job
%    \begin{macrocode}
   \fc@@check@nonzeros@inner
%    \end{macrocode}
% And finally, we propagate the output after end of group --- i.e. closing brace.
%    \begin{macrocode}
   \def\@tempd##1{\def\@tempa{\def#3{##1}}}%
   \expandafter\@tempd\expandafter{\@tempc}%
   \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro\fc@@check@nonzeros@inner Macro \cs{fc@@check@nonzeros@inner} Check wehther some part of the
% parsed value contains some non-zero digit At the call of this macro we expect that:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash}rX@{}}
%   \cs{@tempa}&input/output macro:\newline\noindent
%   \settowidth{\tabcolwidth}{output}%
%   \begin{tabular*}{\hsize}{@{}>{\raggedleft\arraybackslash\itshape}r%
%     p{\dimexpr\hsize-2\tabcolsep-\tabcolwidth}@{}}
%     input&minimum unit unit weight at which start to search the non-zeros\\
%     output&macro may have been redefined
%   \end{tabular*}\\
%   \cs{@tempb}&input/output macro:\newline\noindent
%   \settowidth{\tabcolwidth}{output}%
%   \begin{tabular*}{\hsize}{@{}>{\raggedleft\arraybackslash\itshape}r%
%     p{\dimexpr\hsize-2\tabcolsep-\tabcolwidth}@{}}
% input&maximum unit weight at which end to seach the non-zeros\\
% output&macro may have been redefined
% \end{tabular*}\\
% \cs{@tempc}&ouput macro: 0 if all-zeros, 1 if at least one zero is found\\
% \cs{count0}&output counter: \(\mathrm{weight}+1\) of the first found non zero starting from minimum
% \(\mathrm{weight}\).
% \end{tabularx}
%    \begin{macrocode}
\def\fc@@check@nonzeros@inner{%
   \ifnum\count0<\fc@min@weight
      \count0=\fc@min@weight\relax
   \fi
   \ifnum\count1>\fc@max@weight\relax
      \count1=\fc@max@weight
   \fi
   \count2\count0 %
   \advance\count2 by 1 %
   \ifnum\count0>\count1 %
     \PackageError{fcnumparser}{Unexpected arguments}{Number in argument 2 of macro
       `fc@check@nonzeros' must be at least equal to number in argument 1}%
   \else
     \fc@@check@nonzeros@inner@loopbody
     \ifnum\@tempc>0 %
       \ifnum\@tempc<9 %
         \ifnum\count0>\count1 %
         \else
           \let\@tempd\@tempc
           \fc@@check@nonzeros@inner@loopbody
           \ifnum\@tempc=0 %
             \let\@tempc\@tempd
           \else
             \def\@tempc{9}%
           \fi
         \fi
       \fi
     \fi
   \fi
}
%    \end{macrocode}
%    \begin{macrocode}
\def\fc@@check@nonzeros@inner@loopbody{%
   % \@tempc <-  digit of weight \count0
   \expandafter\let\expandafter\@tempc\csname fc@digit@\the\count0\endcsname
   \advance\count0 by 1 %
   \ifnum\@tempc=0 %
      \ifnum\count0>\count1 %
        \let\next\relax
      \else
        \let\next\fc@@check@nonzeros@inner@loopbody
      \fi
   \else
      \ifnum\count0>\count2 %
        \def\@tempc{9}%
      \fi
      \let\next\relax
   \fi
   \next
}
%    \end{macrocode}
% \DescribeMacro\fc@intpart@find@last Macro \cs{fc@intpart@find@last} find the rightmost non zero digit in the
% integer part. First check that the macro is not yet defined.
%    \begin{macrocode}
\@ifundefined{fc@intpart@find@last}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of macro
    `fc@intpart@find@last'}}
%    \end{macrocode}
% When macro is called, the number of interest is already parsed, that is to say each digit of weight \(w\) is
% stored in macro \cs{fc@digit@}\meta{$w$}.  Macro \cs{fc@intpart@find@last} takes one single argument which
% is a counter to set to the result.
%    \begin{macrocode}
\def\fc@intpart@find@last#1{%
  {%
%    \end{macrocode}
% Counter \cs{count0} will hold the result. So we will loop on \cs{count0}, starting from
% \(\min\{u,w_{\mathrm{min}}\}\), where \(u\triangleq\cs{fc@unit@weight}\), and
% \(w_{\mathrm{min}}\triangleq\cs{fc@min@weight}\). So first set \cs{count0} to
% \(\min\{u,w_{\mathrm{min}}\}\):
%    \begin{macrocode}
    \count0=\fc@unit@weight\space
    \ifnum\count0<\fc@min@weight\space
      \count0=\fc@min@weight\space
    \fi
%    \end{macrocode}
% Now the loop. This is done by defining macro \cs{@templ} for final recursion.
%    \begin{macrocode}
    \def\@templ{%
      \ifnum\csname fc@digit@\the\count0\endcsname=0 %
        \advance\count0 by 1 %
        \ifnum\count0>\fc@max@weight\space
          \let\next\relax
        \fi
      \else
        \let\next\relax
      \fi
      \next
    }%
    \let\next\@templ
    \@templ
%    \end{macrocode}
% Now propagate result after closing bracket into counter \texttt{\#1}.
%    \begin{macrocode}
     \toks0{#1}%
     \edef\@tempa{\the\toks0=\the\count0}%
     \expandafter
  }\@tempa\space
}
%    \end{macrocode}
% \DescribeMacro\fc@get@last@word Getting last word. Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#1&input: full sequence\\
%   \#2&output macro 1: all sequence without last word\\
%   \#3&output macro 2: last word\\
% \end{tabularx}
%    \begin{macrocode}
\@ifundefined{fc@get@last@word}{}{\PackageError{fcnumparser}{Duplicate definition}{Redefinition 
    of macro `fc@get@last@word'}}%
\def\fc@get@last@word#1#2#3{%
  {%
%    \end{macrocode}
% First we split \texttt{\#1} into two parts: everything that is upto \cs{fc@case} exclusive goes to
% \cs{toks0}, and evrything from \cs{fc@case} exclusive upto the final \cs{@nil} exclusive goes to \cs{toks1}.
%    \begin{macrocode}
    \def\@tempa##1\fc@case##2\@nil\fc@end{%
      \toks0{##1}%
%    \end{macrocode}
% Actually a dummy \cs{fc@case} is appended to \cs{toks1}, because that makes easier further checking that it
% does not contains any other \cs{fc@case}.
%    \begin{macrocode}
      \toks1{##2\fc@case}%
    }%
    \@tempa#1\fc@end
%    \end{macrocode}
% Now leading part upto last word should be in \cs{toks0}, and last word should be in \cs{toks1}. However we
% need to check that this is really the last word, i.e. we need to check that there is no \cs{fc@case} inside
% \cs{toks1} other than the tailing dummy one. To that purpose we will loop while we find that \cs{toks1}
% contains some \cs{fc@case}. First we define \cs{@tempa} to split \cs{the}\cs{toks1} between parts before and
% after some potential \cs{fc@case}.
%    \begin{macrocode}
    \def\@tempa##1\fc@case##2\fc@end{%
      \toks2{##1}%
      \def\@tempb{##2}%
      \toks3{##2}%
    }%
%    \end{macrocode}
% \cs{@tempt} is just an aliases of \cs{toks0} to make its handling easier later on.
%    \begin{macrocode}
    \toksdef\@tempt0 %
%    \end{macrocode}
% Now the loop itself, this is done by terminal recursion with macro \cs{@templ}.
%    \begin{macrocode}
    \def\@templ{%
      \expandafter\@tempa\the\toks1 \fc@end
      \ifx\@tempb\@empty
%    \end{macrocode}
% \cs{@tempb} empty means that the only \cs{fc@case} found in \cs{the}\cs{toks1} is the dummy one. So we end
% the loop here, \cs{toks2} contains the last word.
%    \begin{macrocode}
        \let\next\relax
      \else
%    \end{macrocode}
% \cs{@tempb} is not empty, first we use 
%    \begin{macrocode}
         \expandafter\expandafter\expandafter\@tempt
         \expandafter\expandafter\expandafter{%
           \expandafter\the\expandafter\@tempt
           \expandafter\fc@case\the\toks2}%
         \toks1\toks3 %
      \fi
      \next
    }%
    \let\next\@templ
    \@templ
    \edef\@tempa{\def\noexpand#2{\the\toks0}\def\noexpand#3{\the\toks2}}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro\fc@get@last@word Getting last letter. Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#1&input: full word\\
%   \#2&output macro 1: all word without last letter\\
%   \#3&output macro 2: last letter\\
% \end{tabularx}
%    \begin{macrocode}
\@ifundefined{fc@get@last@letter}{}{\PackageError{fcnumparser}{Duplicate definition}{Redefinition 
    of macro `fc@get@last@letter'}}%
\def\fc@get@last@letter#1#2#3{%
  {%
%    \end{macrocode}
% First copy input to local \cs{toks1}. What we are going to to is to bubble one by one letters from
% \cs{toks1} which initial contains the whole word, into \cs{toks0}. At the end of the macro \cs{toks0} will
% therefore contain the whole work but the last letter, and the last letter will be in \cs{toks1}.
%    \begin{macrocode}
    \toks1{#1}%
    \toks0{}%
    \toksdef\@tempt0 %
%    \end{macrocode}
% We define \cs{@tempa} in order to pop the first letter from the remaining of word.
%    \begin{macrocode}
    \def\@tempa##1##2\fc@nil{%
      \toks2{##1}%
      \toks3{##2}%
      \def\@tempb{##2}%
    }%
%    \end{macrocode}
% Now we define \cs{@templ} to do the loop by terminal recursion.
%    \begin{macrocode}
    \def\@templ{%
      \expandafter\@tempa\the\toks1 \fc@nil
      \ifx\@tempb\@empty
%    \end{macrocode}
% Stop loop, as \cs{toks1} has been detected to be one single letter.
%    \begin{macrocode}
        \let\next\relax
      \else
%    \end{macrocode}
% Here we append to \cs{toks0} the content of \cs{toks2}, i.e. the next letter.
%    \begin{macrocode}
         \expandafter\expandafter\expandafter\@tempt
         \expandafter\expandafter\expandafter{%
           \expandafter\the\expandafter\@tempt
           \the\toks2}%
%    \end{macrocode}
% And the remaining letters go to \cs{toks1} for the next iteration.
%    \begin{macrocode}
        \toks1\toks3 %
      \fi
      \next
    }%
%    \end{macrocode}
% Here run the loop.
%    \begin{macrocode}
    \let\next\@templ
    \next
%    \end{macrocode}
% Now propagate the results into macros \texttt{\#2} and \texttt{\#3} after closing brace.
%    \begin{macrocode}
    \edef\@tempa{\def\noexpand#2{\the\toks0}\def\noexpand#3{\the\toks1}}%
    \expandafter
  }\@tempa
}%
%    \end{macrocode}
\iffalse Local variables: \fi
\iffalse mode: docTeX     \fi
\iffalse End:             \fi
%\iffalse
%    \begin{macrocode}
%</fcnumparser.sty>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fcprefix.sty>
%    \end{macrocode}
%\fi
%\subsection{fcprefix.sty}
% Pseudo-latin prefixes.
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{fcprefix}[2012/09/28]
\RequirePackage{ifthen}
\RequirePackage{keyval}
\RequirePackage{fcnumparser}
%    \end{macrocode}
% Option `\texttt{use duode and unde}' is to select whether \(18\) and suchlikes (\(\meta{x}8\),
% \(\meta{x}9\)) writes like duodevicies, or like octodecies. For French it should be `\texttt{below
% 20}'. Possible values are `\texttt{below 20}' and `\texttt{never}'.
%    \begin{macrocode}
\define@key{fcprefix}{use duode and unde}[below20]{%
  \ifthenelse{\equal{#1}{below20}}{%
    \def\fc@duodeandunde{2}%
  }{%
    \ifthenelse{\equal{#1}{never}}{%
      \def\fc@duodeandunde{0}%
    }{%
      \PackageError{fcprefix}{Unexpected option}{%
        Option `use duode and unde' expects `below 20' or `never' }%
    }%
  }%
}
%    \end{macrocode}
% Default is `\texttt{below 20}' like in French.
%    \begin{macrocode}
\def\fc@duodeandunde{2}
%    \end{macrocode}
% Option `\texttt{numeral u in duo}', this can be `\texttt{true}' or `\texttt{false}' and is used to select
% whether 12 and suchlikes write like dodec\meta{xxx} or duodec\meta{xxx} for numerals.
%    \begin{macrocode}
\define@key{fcprefix}{numeral u in duo}[false]{%
  \ifthenelse{\equal{#1}{false}}{%
    \let\fc@u@in@duo\@empty
  }{%
    \ifthenelse{\equal{#1}{true}}{%
      \def\fc@u@in@duo{u}%
    }{%
      \PackageError{fcprefix}{Unexpected option}{%
        Option `numeral u in duo' expects `true' or `false' }%
    }%
  }%
}
%    \end{macrocode}
% Option `\texttt{e accute}', this can be `\texttt{true}' or `\texttt{false}' and is used to select whether
% letter `\texttt{e}' has an accute accent when it pronounce [e] in French.
%    \begin{macrocode}
\define@key{fcprefix}{e accute}[false]{%
  \ifthenelse{\equal{#1}{false}}{%
    \let\fc@prefix@eaccute\@firstofone
  }{%
    \ifthenelse{\equal{#1}{true}}{%
      \let\fc@prefix@eaccute\'%
    }{%
      \PackageError{fcprefix}{Unexpected option}{%
        Option `e accute' expects `true' or `false' }%
    }%
  }%
}
%    \end{macrocode}
% Default is to set accute accent like in French.
%    \begin{macrocode}
\let\fc@prefix@eaccute\'%
%    \end{macrocode}
% Option `\texttt{power of millia}' tells how millia is raise to power n. It expects value:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% recursive&for which millia squared is noted as `milliamillia'\\
% arabic&for which millia squared is noted as `millia\^{}2'\\
% prefix&for which millia squared is noted as `bismillia'
% \end{tabularx}
%    \begin{macrocode}
\define@key{fcprefix}{power of millia}[prefix]{%
  \ifthenelse{\equal{#1}{prefix}}{%
       \let\fc@power@of@millia@init\@gobbletwo
       \let\fc@power@of@millia\fc@@prefix@millia
  }{%
    \ifthenelse{\equal{#1}{arabic}}{%
       \let\fc@power@of@millia@init\@gobbletwo
       \let\fc@power@of@millia\fc@@arabic@millia
    }{%
      \ifthenelse{\equal{#1}{recursive}}{%
        \let\fc@power@of@millia@init\fc@@recurse@millia@init
        \let\fc@power@of@millia\fc@@recurse@millia
      }{%
        \PackageError{fcprefix}{Unexpected option}{%
          Option `power of millia' expects `recursive', `arabic', or `prefix' }%
      }%
    }%
  }%
}
%    \end{macrocode}
% Arguments as follows:\def\interface{\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1& output macro\\
% \#2& number with current weight \(w\)
% \end{tabularx}}\interface
%    \begin{macrocode}
\def\fc@@recurse@millia#1#2{%
  \let\@tempp#1%
  \edef#1{millia\@tempp}%
}
%    \end{macrocode}
% Arguments as follows --- same interface as \cs{fc@@recurse@millia}: \interface
%    \begin{macrocode}
\def\fc@@recurse@millia@init#1#2{%
  {%
%    \end{macrocode}
% Save input argument current weight \(w\) into local macro \cs{@tempb}.
%    \begin{macrocode}
    \edef\@tempb{\number#2}%
%    \end{macrocode}
% Now main loop from 0 to \(w\). Final value of \cs{@tempa} will be the result.
%    \begin{macrocode}
    \count0=0 %
    \let\@tempa\@empty
    \loop
       \ifnum\count0<\@tempb
         \advance\count0 by 1 %
         \expandafter\def
           \expandafter\@tempa\expandafter{\@tempa millia}%
    \repeat
%    \end{macrocode}
% Now propagate the expansion of \cs{@tempa} into \texttt{\#1} after closing bace.
%    \begin{macrocode}
    \edef\@tempb{\def\noexpand#1{\@tempa}}%
    \expandafter
  }\@tempb
}
%    \end{macrocode}
% Arguments as follows --- same interface as \cs{fc@@recurse@millia}: \interface
%    \begin{macrocode}
\def\fc@@arabic@millia#1#2{%
  \ifnnum#2=0 %
    \let#1\@empty
  \else
    \edef#1{millia\^{}\the#2}%
  \fi
}
%    \end{macrocode}
% Arguments as follows --- same interface as \cs{fc@@recurse@millia}: \interface
%    \begin{macrocode}
\def\fc@@prefix@millia#1#2{%
  \fc@@latin@numeral@pefix{#2}{#1}%
}
%    \end{macrocode}
% Default value of option `\texttt{power of millia}' is `\texttt{prefix}':
%    \begin{macrocode}
\let\fc@power@of@millia@init\@gobbletwo
\let\fc@power@of@millia\fc@@prefix@millia
%    \end{macrocode}
% \DescribeMacro\fc@@latin@cardinal@pefix Compute a cardinal prefix for n-illion, like \(1 \Rightarrow
% \textrm{`m'}\), \(2 \Rightarrow \textrm{`bi'}\), \(3 \Rightarrow \textrm{`tri'}\). The algorithm to derive
% this prefix is that of Russ Rowlett I founds its documentation on Alain Lassine's site:
% \url{http://www.alain.be/Boece/grands\_nombres.html}. First check that macro is not yet defined.
%    \begin{macrocode}
\@ifundefined{fc@@latin@cardinal@pefix}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro `fc@@latin@cardinal@pefix'}}
%    \end{macrocode}
% Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&input number to be formated\\
% \#2&outut macro name into which to place the formatted result
% \end{tabularx}
%    \begin{macrocode}
\def\fc@@latin@cardinal@pefix#1#2{%
  {%
%    \end{macrocode}
% First we put input argument into local macro @cs{@tempa} with full expansion.
%    \begin{macrocode}
    \edef\@tempa{\number#1}%
%    \end{macrocode}
% Now parse number from expanded input.
%    \begin{macrocode}
    \expandafter\fc@number@parser\expandafter{\@tempa}%
    \count2=0 %
%    \end{macrocode}
% \cs{@tempt} will hold the optional final \texttt{t}, \cs{@tempu} is used to initialize \cs{@tempt} to `t'
% when the firt non-zero 3digit group is met, which is the job made by \cs{@tempi}.
%    \begin{macrocode}
    \let\@tempt\@empty
    \def\@tempu{t}%
%    \end{macrocode}
% \cs{@tempm} will hold the \texttt{millia\^}\(^{n\div 3}\)
%    \begin{macrocode}
    \let\@tempm\@empty
%    \end{macrocode}
% Loop by means of terminal recursion of herinafter defined macro \cs{@templ}. We loop by group of 3 digits.
%    \begin{macrocode}
    \def\@templ{%
      \ifnum\count2>\fc@max@weight
        \let\next\relax
      \else
%    \end{macrocode}
% Loop body. Here we read a group of 3 consecutive digits \(d_2d_1d_0\) and place them respectively into
% \cs{count3}, \cs{count4}, and \cs{count5}.
%    \begin{macrocode}
        \fc@read@unit{\count3}{\count2}%
        \advance\count2 by 1 %
        \fc@read@unit{\count4}{\count2}%
        \advance\count2 by 1 %
        \fc@read@unit{\count5}{\count2}%
        \advance\count2 by 1 %
%    \end{macrocode}
% If the 3 considered digits \(d_2d_1d_0\) are not all zero, then set \cs{@tempt} to `\texttt{t}' for the
% first time this event is met.
%    \begin{macrocode}
        \edef\@tempn{%
          \ifnum\count3=0\else 1\fi
          \ifnum\count4=0\else 1\fi
          \ifnum\count5=0\else 1\fi
        }%
        \ifx\@tempn\@empty\else
          \let\@tempt\@tempu
          \let\@tempu\@empty
        \fi
%    \end{macrocode}
% Now process the current group \(d_2d_1d_0\) of 3 digits.
%    \begin{macrocode}
        \let\@tempp\@tempa
        \edef\@tempa{%
%    \end{macrocode}
% Here we process \(d_{2}\) held by \cs{count5}, that is to say hundreds.
%    \begin{macrocode}
          \ifcase\count5 %
          \or cen%
          \or ducen%
          \or trecen%
          \or quadringen%
          \or quingen%
          \or sescen%
          \or septigen%
          \or octingen%
          \or nongen%
          \fi
%    \end{macrocode}
% Here we process \(d_1d_0\) held by \cs{count4} \& \cs{count3}, that is to say tens and units.
%    \begin{macrocode}
          \ifnum\count4=0 %
            % x0(0..9)
            \ifnum\count2=3 %
              % Absolute weight zero
              \ifcase\count3 \@tempt
              \or m%
              \or b%
              \or tr% 
              \or quadr%
              \or quin\@tempt
              \or sex\@tempt
              \or sep\@tempt
              \or oc\@tempt
              \or non%
              \fi
            \else
%    \end{macrocode}
% Here the weight of \cs{count3} is \(3\times n\), with \(n>0\), i.e. this is followed by a
% \texttt{millia\^}\(n\).
%    \begin{macrocode}
              \ifcase\count3 %
              \or \ifnum\count2>\fc@max@weight\else un\fi
              \or d\fc@u@in@duo o%
              \or tre%
              \or quattuor%
              \or quin%
              \or sex%
              \or septen%
              \or octo%
              \or novem%
              \fi
            \fi
          \else
             % x(10..99)
             \ifcase\count3 %
             \or un%
             \or d\fc@u@in@duo o%
             \or tre%
             \or quattuor%
             \or quin%
             \or sex%
             \or septen%
             \or octo%
             \or novem%
             \fi
             \ifcase\count4 %
             \or dec%
             \or vigin\@tempt
             \or trigin\@tempt
             \or quadragin\@tempt
             \or quinquagin\@tempt
             \or sexagin\@tempt
             \or septuagin\@tempt
             \or octogin\@tempt
             \or nonagin\@tempt
             \fi
          \fi
%    \end{macrocode}
% Insert the \texttt{millia\^}\(^{(n\div 3)}\) only if \(d_2d_1d_0\not=0\), i.e. if one of \cs{count3}
% \cs{count4} or \cs{count5} is non zero.
%    \begin{macrocode}
          \@tempm
%    \end{macrocode}
% And append previous version of \cs{@tempa}.
%    \begin{macrocode}
          \@tempp
        }%
%    \end{macrocode}
% ``Concatenate'' \texttt{millia} to \cs{@tempm}, so that \cs{@tempm} will expand to
% \texttt{millia\^}\(^{(n\div 3)+1}\) at the next iteration. Actually whether this is a concatenation or some
% \texttt{millia} prefixing depends of option `\texttt{power of millia}'.
%    \begin{macrocode}
        \fc@power@of@millia\@tempm{\count2}%
      \fi
      \next
    }%
    \let\@tempa\@empty
    \let\next\@templ
    \@templ
%    \end{macrocode}
% Propagate expansion of \cs{@tempa} into \texttt{\#2} after closing bracket.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def#2{##1}}}%
    \expandafter\@tempb\expandafter{\@tempa}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro\fc@@latin@numeral@pefix Compute a numeral prefix
% like `s\'emel', `bis', `ter', `quater',
% etc\ldots I found the algorithm to derive this prefix on Alain Lassine's site:
% \url{http://www.alain.be/Boece/nombres\_gargantuesques.html}. First check that the macro is not yet defined.
%    \begin{macrocode}
\@ifundefined{fc@@latin@numeral@pefix}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro 
    `fc@@latin@numeral@pefix'}}
%    \end{macrocode}
% Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1& input number to be formatted,\\
% \#2&  outut macro name into which to place the result
% \end{tabularx}
%    \begin{macrocode}
\def\fc@@latin@numeral@pefix#1#2{%
  {%
    \edef\@tempa{\number#1}%
    \def\fc@unit@weight{0}%
    \expandafter\fc@number@parser\expandafter{\@tempa}%
    \count2=0 %
%    \end{macrocode}
% Macro \cs{@tempm} will hold the \texttt{millies\^}\(^{n\div 3}\).
%    \begin{macrocode}
    \let\@tempm\@empty
%    \end{macrocode}
% Loop over digits. This is done by defining macro \cs{@templ} for terminal recursion.
%    \begin{macrocode}
    \def\@templ{%
      \ifnum\count2>\fc@max@weight
        \let\next\relax
      \else
%    \end{macrocode}
% Loop body. Three consecutive digits \(d_{2}d_{1}d_{0}\) are read into counters \cs{count3}, \cs{count4}, and
% \cs{count5}.
%    \begin{macrocode}
        \fc@read@unit{\count3}{\count2}%
        \advance\count2 by 1 %
        \fc@read@unit{\count4}{\count2}%
        \advance\count2 by 1 %
        \fc@read@unit{\count5}{\count2}%
        \advance\count2 by 1 %
%    \end{macrocode}
% Check the use of \texttt{duodevicies} instead of \texttt{octodecies}.
%    \begin{macrocode}
        \let\@tempn\@secondoftwo
        \ifnum\count3>7 %
          \ifnum\count4<\fc@duodeandunde
            \ifnum\count4>0 %
               \let\@tempn\@firstoftwo
             \fi
          \fi
        \fi
        \@tempn
        {% use duodevicies for eighteen
          \advance\count4 by 1 %
          \let\@temps\@secondoftwo
        }{%  do not use duodevicies for eighteen
          \let\@temps\@firstoftwo
        }%
        \let\@tempp\@tempa
        \edef\@tempa{%
          % hundreds
          \ifcase\count5 %
          \expandafter\@gobble
          \or c%
          \or duc%
          \or trec%
          \or quadring%
          \or quing%
          \or sesc%
          \or septing%
          \or octing%
          \or nong%
          \fi
          {enties}%
          \ifnum\count4=0 %
%    \end{macrocode}
% Here \(d_{2}d_{1}d_{0}\) is such that \(d_{1} = 0\).
%    \begin{macrocode}
            \ifcase\count3 %
            \or
              \ifnum\count2=3 %
                s\fc@prefix@eaccute emel%
              \else
                \ifnum\count2>\fc@max@weight\else un\fi
              \fi
            \or bis%
            \or ter% 
            \or quater%
            \or quinquies%
            \or sexies%
            \or septies%
            \or octies%
            \or novies%
            \fi
          \else
%    \end{macrocode}
% Here \(d_{2}d_{1}d_{0}\) is such that \(d_{1} \geq 1\).
%    \begin{macrocode}
             \ifcase\count3 %
             \or un%
             \or d\fc@u@in@duo o%
             \or ter%
             \or quater%
             \or quin%
             \or sex%
             \or septen%
             \or \@temps{octo}{duod\fc@prefix@eaccute e}% x8 = two before next (x+1)0
             \or \@temps{novem}{und\fc@prefix@eaccute e}% x9 = one before next (x+1)0
             \fi
             \ifcase\count4 %
             % can't get here
             \or d\fc@prefix@eaccute ec%
             \or vic%
             \or tric%
             \or quadrag%
             \or quinquag%
             \or sexag%
             \or septuag%
             \or octog%
             \or nonag%
             \fi
             ies%
          \fi
          % Insert the millies^(n/3) only if one of \count3 \count4 \count5 is non zero
          \@tempm
          % add up previous version of \@tempa
          \@tempp
        }%
%    \end{macrocode}
% Concatenate \texttt{millies} to \cs{@tempm} so that it is equal to \texttt{millies\^}\(^{n\div 3}\) at the
% next iteration. Here we just have plain concatenation, contrary to cardinal for which a prefix can be used
% instead.
%    \begin{macrocode}
        \let\@tempp\@tempp
        \edef\@tempm{millies\@tempp}%
      \fi
      \next
    }%
    \let\@tempa\@empty
    \let\next\@templ
    \@templ
%    \end{macrocode}
% Now propagate expansion of \@tempa into \texttt{\#2} after closing bracket.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def#2{##1}}}%
    \expandafter\@tempb\expandafter{\@tempa}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% Stuff for calling macros. Construct \cs{fc@call}\meta{some macro} can be used to pass two arguments to
% \meta{some macro} with a configurable calling convention:
% \begin{itemize}
% \item the calling convention is such that there is one mandatory argument \meta{marg} and an optional
%   argument \meta{oarg}
% \item either \cs{fc@call} is \cs{let} to be equal to \cs{fc@call@opt@arg@second}, and then calling
% convention is that the \meta{marg} is first and \meta{oarg} is second,
% \item or \cs{fc@call} is \cs{let} to be equal to \cs{fc@call@opt@arg@first}, and then calling convention is
%   that the \meta{oarg} is first and \meta{aarg} is second,
% \item if \meta{oarg} is absent, then it is by convention set empty,
% \item \meta{some macro} is supposed to have two mandatory arguments of which \meta{oarg} is passed to the
%   first, and \meta{marg} is passed to the second, and
% \item \meta{some macro} is called within a group.
% \end{itemize}
%    \begin{macrocode}
\def\fc@call@opt@arg@second#1#2{%
  \def\@tempb{%
    \ifx[\@tempa
      \def\@tempc[####1]{%
            {#1{####1}{#2}}%
          }%
    \else
      \def\@tempc{{#1{}{#2}}}%
    \fi
    \@tempc
  }%
  \futurelet\@tempa
  \@tempb
}
%    \end{macrocode}
%    \begin{macrocode}
\def\fc@call@opt@arg@first#1{%
  \def\@tempb{%
    \ifx[\@tempa
      \def\@tempc[####1]####2{{#1{####1}{####2}}}%
    \else
      \def\@tempc####1{{#1{}{####1}}}%
    \fi
    \@tempc
  }%
  \futurelet\@tempa
  \@tempb
}

\let\fc@call\fc@call@opt@arg@first
%    \end{macrocode}
% User API.
% 
% \DescribeMacro\@latinnumeralstringnum Macro \cs{@latinnumeralstringnum}. Arguments as
% follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&local options\\
% \#2& input number
% \end{tabularx}
%    \begin{macrocode}
\newcommand*{\@latinnumeralstringnum}[2]{%
  \setkeys{fcprefix}{#1}%
  \fc@@latin@numeral@pefix{#2}\@tempa
  \@tempa
}
%    \end{macrocode}
% Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&local options\\
% \#2&input counter
% \end{tabularx}
%    \begin{macrocode}
\newcommand*{\@latinnumeralstring}[2]{%
  \setkeys{fcprefix}{#1}%
  \expandafter\let\expandafter
     \@tempa\expandafter\csname c@#2\endcsname
  \expandafter\fc@@latin@numeral@pefix\expandafter{\the\@tempa}\@tempa
  \@tempa
}
%    \end{macrocode}
%    \begin{macrocode}
\newcommand*{\latinnumeralstring}{%
  \fc@call\@latinnumeralstring
}
%    \end{macrocode}
%    \begin{macrocode}
\newcommand*{\latinnumeralstringnum}{%
  \fc@call\@latinnumeralstringnum
}
%    \end{macrocode}
\iffalse Local variables: \fi
\iffalse mode: docTeX     \fi
\iffalse End:             \fi
%\iffalse
%    \begin{macrocode}
%</fcprefix.sty>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fmtcount.sty>
%    \end{macrocode}
%\fi
%\subsection{fmtcount.sty}
% This section deals with the code for |fmtcount.sty|
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{fmtcount}[2012/10/24 v2.02]
\RequirePackage{ifthen}
\RequirePackage{keyval}
\RequirePackage{etoolbox}
\RequirePackage{fcprefix}
%    \end{macrocode}
% \changes{1.3}{2007/7/19}{no
%longer using xspace package}
%\changes{1.31}{2009/10/02}{amsgen now loaded (\cs{new@ifnextchar}
% needed)}
% Need to use \cs{new@ifnextchar} instead of \cs{@ifnextchar} in
% commands that have a final optional argument (such as \cs{gls})
% so require \sty{amsgen}.
%    \begin{macrocode}
\RequirePackage{amsgen}
%    \end{macrocode}
% These commands need to be defined before the
% configuration file is loaded.
%
% Define the macro to format the |st|, |nd|, |rd| or |th| of an 
% ordinal.
%\begin{macro}{\fmtord}
%    \begin{macrocode}
\providecommand*{\fmtord}[1]{\textsuperscript{#1}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\padzeroes}
%\begin{definition}
%\cs{padzeroes}\oarg{n}
%\end{definition}
% Specifies how many digits should be displayed for commands such as
% \cs{decimal} and \cs{binary}.
%    \begin{macrocode}
\newcount\c@padzeroesN
\c@padzeroesN=1\relax
\providecommand*{\padzeroes}[1][17]{\c@padzeroesN=#1}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\FCloadlang}
%changes{2.0}{2012-06-18}{new}
%changes{2.02}{2012-10-24}{ensured catcode for @ set to `letter'
%before loading file}
%\begin{definition}
%\cs{FCloadlang}\marg{language}
%\end{definition}
% Load \styfmt{fmtcount} language file,
% \texttt{fc-}\meta{language}\texttt{.def}, unless already loaded.
%    \begin{macrocode}
\newcount\fc@tmpcatcode
\def\fc@languages{}
\def\fc@mainlang{}%
\newcommand*{\FCloadlang}[1]{%
  \@FC@iflangloaded{#1}{}%
  {%
    \fc@tmpcatcode=\catcode`\@\relax
    \catcode `\@ 11\relax
    \input{fc-#1.def}%
    \catcode `\@ \fc@tmpcatcode\relax
    \ifdefempty{\fc@languages}%
    {%
      \def\fc@languages{#1}%
    }%
    {%
       \appto\fc@languages{,#1}%
    }%
    \def\fc@mainlang{#1}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@FC@iflangloaded}
%changes{2.0}{2012-06-18}{new}
%\begin{definition}
%\cs{@FC@iflangloaded}\marg{language}\marg{true}\marg{false}
%\end{definition}
%If fmtcount language definition file \texttt{fc-}\meta{language}\texttt{.def} has
%been loaded, do \meta{true} otherwise do \meta{false}
%    \begin{macrocode}
\newcommand{\@FC@iflangloaded}[3]{%
  \ifcsundef{ver@fc-#1.def}{#3}{#2}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ProvidesFCLanguage}
%changes{2.0}{2012-06-18}{new}
% Declare fmtcount language definition file. Adapted from
% \ics{ProvidesFile}.
%    \begin{macrocode}
\newcommand*{\ProvidesFCLanguage}[1]{%
  \ProvidesFile{fc-#1.def}%
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\@fc@loadifbabelldf}
%\begin{definition}
%\cs{@fc@loadigbabelldf}\marg{language}
%\end{definition}
%Loads fmtcount language file,
%\texttt{fc-}\meta{language}\texttt{.def}, 
% if babel language definition file
% \meta{language}\texttt{.ldf} has been loaded.
%    \begin{macrocode}
\newcommand*{\@fc@loadifbabelldf}[1]{%
  \ifcsundef{ver@#1.ldf}{}{\FCloadlang{#1}}%
}
%    \end{macrocode}
%\end{macro}
%
% Load appropriate language definition files:
%\changes{1.1}{14 June 2007}{added check for UKenglish,
% british and USenglish babel settings}
%\changes{2.0}{2012-06-18}{changed check for \cs{l@}\meta{language} 
% to check for \cs{date}\meta{language}}
%    \begin{macrocode}
\@fc@loadifbabelldf{english}
\@fc@loadifbabelldf{UKenglish}
\@fc@loadifbabelldf{british}
\@fc@loadifbabelldf{USenglish}
\@fc@loadifbabelldf{american}
\@fc@loadifbabelldf{spanish}
\@fc@loadifbabelldf{portuges}
\@fc@loadifbabelldf{french}
\@fc@loadifbabelldf{frenchb}
\@fc@loadifbabelldf{german}%
\@fc@loadifbabelldf{germanb}%
\@fc@loadifbabelldf{ngerman}%
\@fc@loadifbabelldf{ngermanb}%
\@fc@loadifbabelldf{italian}
%    \end{macrocode}
%\begin{macro}{\fmtcount@french}
% Define keys for use with |\fmtcountsetoptions|.
% Key to switch French dialects (Does babel store
%this kind of information?)
%    \begin{macrocode}
\def\fmtcount@french{france}
%    \end{macrocode}
%\end{macro}
%\begin{option}{french}
%    \begin{macrocode}
\define@key{fmtcount}{french}[france]{%
  \@ifundefined{datefrench}%
  {%
    \PackageError{fmtcount}%
    {Language `french' not defined}%
    {You need to load babel before loading fmtcount}%
  }%
  {%
    \setkeys{fcfrench}{#1}%
  }%
}
%    \end{macrocode}
%\end{option}
%\begin{option}{fmtord}
% Key to determine how to display the ordinal
%    \begin{macrocode}
\define@key{fmtcount}{fmtord}{%
  \ifthenelse{\equal{#1}{level}
           \or\equal{#1}{raise}
           \or\equal{#1}{user}}%
  {%
    \def\fmtcount@fmtord{#1}%
  }%
  {%
    \PackageError{fmtcount}%
    {Invalid value `#1' to fmtord key}%
    {Option `fmtord' can only take the values `level', `raise'
     or `user'}%
  }%
}
%    \end{macrocode}
%\end{option}
%\begin{macro}{\iffmtord@abbrv}
% Key to determine whether the ordinal should be abbreviated
% (language dependent, currently only affects French ordinals.)
%    \begin{macrocode}
\newif\iffmtord@abbrv
\fmtord@abbrvfalse
\define@key{fmtcount}{abbrv}[true]{%
  \ifthenelse{\equal{#1}{true}\or\equal{#1}{false}}%
  {%
    \csname fmtord@abbrv#1\endcsname
  }%
  {%
    \PackageError{fmtcount}%
    {Invalid value `#1' to fmtord key}%
    {Option `fmtord' can only take the values `true' or
     `false'}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{option}{prefix}
%\changes{2.0}{2012-06-18}{new}
%    \begin{macrocode}
\define@key{fmtcount}{prefix}[scale=long]{%
  \RequirePackage{fmtprefix}%
  \fmtprefixsetoption{#1}%
}
%    \end{macrocode}
%\end{option}
%\begin{macro}{\fmtcountsetoptions}
% Define command to set options.
%    \begin{macrocode}
\newcommand*{\fmtcountsetoptions}[1]{%
  \def\fmtcount@fmtord{}%
  \setkeys{fmtcount}{#1}%
  \@ifundefined{datefrench}{}%
  {%
    \edef\@ordinalstringMfrench{\noexpand
      \csname @ordinalstringMfrench\fmtcount@french\noexpand\endcsname}%
    \edef\@ordinalstringFfrench{\noexpand
      \csname @ordinalstringFfrench\fmtcount@french\noexpand\endcsname}%
    \edef\@OrdinalstringMfrench{\noexpand
      \csname @OrdinalstringMfrench\fmtcount@french\noexpand\endcsname}%
    \edef\@OrdinalstringFfrench{\noexpand
      \csname @OrdinalstringFfrench\fmtcount@french\noexpand\endcsname}%
    \edef\@numberstringMfrench{\noexpand
      \csname @numberstringMfrench\fmtcount@french\noexpand\endcsname}%
    \edef\@numberstringFfrench{\noexpand
      \csname @numberstringFfrench\fmtcount@french\noexpand\endcsname}%
    \edef\@NumberstringMfrench{\noexpand
      \csname @NumberstringMfrench\fmtcount@french\noexpand\endcsname}%
    \edef\@NumberstringFfrench{\noexpand
      \csname @NumberstringFfrench\fmtcount@french\noexpand\endcsname}%
  }%
  \ifthenelse{\equal{\fmtcount@fmtord}{level}}%
  {%
    \renewcommand{\fmtord}[1]{##1}%
  }%
  {%
    \ifthenelse{\equal{\fmtcount@fmtord}{raise}}%
    {%
      \renewcommand{\fmtord}[1]{\textsuperscript{##1}}%
    }%
    {%
    }%
  }
}
%    \end{macrocode}
%\end{macro}
% Load confguration file if it exists.  This needs to be done
% before the package options, to allow the user to override
% the settings in the configuration file.
%\changes{2.0}{2012-06-18}{Now no message if fmtcount.cfg not found}
%    \begin{macrocode}
\InputIfFileExists{fmtcount.cfg}%
{%
  \PackageInfo{fmtcount}{Using configuration file fmtcount.cfg}%
}%
{%
}
%    \end{macrocode}
%\begin{option}{level}
%    \begin{macrocode}
\DeclareOption{level}{\def\fmtcount@fmtord{level}%
  \def\fmtord#1{#1}}
%    \end{macrocode}
%\end{option}
%\begin{option}{raise}
%    \begin{macrocode}
\DeclareOption{raise}{\def\fmtcount@fmtord{raise}%
  \def\fmtord#1{\textsuperscript{#1}}}
%    \end{macrocode}
%\end{option}
% Process package options
%    \begin{macrocode}
\ProcessOptions
%    \end{macrocode}
%\begin{macro}{\@modulo}
%\begin{definition}
%\cs{@modulo}\marg{count reg}\marg{n}
%\end{definition}
% Sets the count register to be its value modulo \meta{n}. 
% This is used for the
% date, time, ordinal and numberstring commands. (The
% \styfmt{fmtcount} package was originally part of the 
% \sty{datetime} package.)
%    \begin{macrocode}
\newcount\@DT@modctr
\def\@modulo#1#2{%
  \@DT@modctr=#1\relax
  \divide \@DT@modctr by #2\relax
  \multiply \@DT@modctr by #2\relax
  \advance #1 by -\@DT@modctr
}
%    \end{macrocode}
%\end{macro}
% The following registers are needed by |\@ordinal| etc
%    \begin{macrocode}
\newcount\@ordinalctr
\newcount\@orgargctr
\newcount\@strctr
\newcount\@tmpstrctr
%    \end{macrocode}
%Define commands that display numbers in different bases.
% Define counters and conditionals needed.
%    \begin{macrocode}
\newif\if@DT@padzeroes
\newcount\@DT@loopN
\newcount\@DT@X
%    \end{macrocode}
%\begin{macro}{\binarynum}
% Converts a decimal number to binary, and display.
%    \begin{macrocode}
\newcommand*{\@binary}[1]{%
  \@DT@padzeroestrue
  \@DT@loopN=17\relax
  \@strctr=\@DT@loopN
  \whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by 1}%
  \@strctr=65536\relax
  \@DT@X=#1\relax
  \loop
    \@DT@modctr=\@DT@X
    \divide\@DT@modctr by \@strctr
    \ifthenelse{\boolean{@DT@padzeroes}
       \and \(\@DT@modctr=0\)
       \and \(\@DT@loopN>\c@padzeroesN\)}%
    {}%
    {\the\@DT@modctr}%
    \ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
    \multiply\@DT@modctr by \@strctr
    \advance\@DT@X by -\@DT@modctr
    \divide\@strctr by 2\relax
    \advance\@DT@loopN by -1\relax
  \ifnum\@strctr>1
  \repeat
  \the\@DT@X
}

\let\binarynum=\@binary
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\octalnum}
% Converts a decimal number to octal, and displays.
%    \begin{macrocode}
\newcommand*{\@octal}[1]{%
  \ifnum#1>32768
    \PackageError{fmtcount}%
    {Value of counter too large for \protect\@octal}
    {Maximum value 32768}
  \else
  \@DT@padzeroestrue
  \@DT@loopN=6\relax
  \@strctr=\@DT@loopN
  \whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by 1}%
  \@strctr=32768\relax
  \@DT@X=#1\relax
  \loop
    \@DT@modctr=\@DT@X
    \divide\@DT@modctr by \@strctr
    \ifthenelse{\boolean{@DT@padzeroes}
       \and \(\@DT@modctr=0\)
       \and \(\@DT@loopN>\c@padzeroesN\)}%
    {}{\the\@DT@modctr}%
    \ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
    \multiply\@DT@modctr by \@strctr
    \advance\@DT@X by -\@DT@modctr
    \divide\@strctr by 8\relax
    \advance\@DT@loopN by -1\relax
  \ifnum\@strctr>1
  \repeat
  \the\@DT@X
  \fi
}
\let\octalnum=\@octal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@@hexadecimalnum}
% Converts number from 0 to 15 into lowercase hexadecimal notation.
%    \begin{macrocode}
\newcommand*{\@@hexadecimal}[1]{%
  \ifcase#10\or1\or2\or3\or4\or5\or
  6\or7\or8\or9\or a\or b\or c\or d\or e\or f\fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\hexadecimalnum}
% Converts a decimal number to a lowercase hexadecimal number, 
% and displays it.
%    \begin{macrocode}
\newcommand*{\@hexadecimal}[1]{%
  \@DT@padzeroestrue
  \@DT@loopN=5\relax
  \@strctr=\@DT@loopN
  \whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by 1}%
  \@strctr=65536\relax
  \@DT@X=#1\relax
  \loop
    \@DT@modctr=\@DT@X
    \divide\@DT@modctr by \@strctr
    \ifthenelse{\boolean{@DT@padzeroes}
      \and \(\@DT@modctr=0\)
      \and \(\@DT@loopN>\c@padzeroesN\)}
    {}{\@@hexadecimal\@DT@modctr}%
    \ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
    \multiply\@DT@modctr by \@strctr
    \advance\@DT@X by -\@DT@modctr
    \divide\@strctr by 16\relax
    \advance\@DT@loopN by -1\relax
  \ifnum\@strctr>1
  \repeat
  \@@hexadecimal\@DT@X
}
\let\hexadecimalnum=\@hexadecimal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@@Hexadecimalnum}
% Converts number from 0 to 15 into uppercase hexadecimal notation.
%    \begin{macrocode}
\newcommand*{\@@Hexadecimal}[1]{%
  \ifcase#10\or1\or2\or3\or4\or5\or6\or
  7\or8\or9\or A\or B\or C\or D\or E\or F\fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Hexadecimalnum}
% Uppercase hexadecimal
%    \begin{macrocode}
\newcommand*{\@Hexadecimal}[1]{%
  \@DT@padzeroestrue
  \@DT@loopN=5\relax
  \@strctr=\@DT@loopN
  \whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by 1}%
  \@strctr=65536\relax
  \@DT@X=#1\relax
  \loop
    \@DT@modctr=\@DT@X
    \divide\@DT@modctr by \@strctr
    \ifthenelse{\boolean{@DT@padzeroes}
      \and \(\@DT@modctr=0\)
      \and \(\@DT@loopN>\c@padzeroesN\)}%
    {}{\@@Hexadecimal\@DT@modctr}%
    \ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
    \multiply\@DT@modctr by \@strctr
    \advance\@DT@X by -\@DT@modctr
    \divide\@strctr by 16\relax
    \advance\@DT@loopN by -1\relax
  \ifnum\@strctr>1
  \repeat
  \@@Hexadecimal\@DT@X
}

\let\Hexadecimalnum=\@Hexadecimal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\aaalphnum}
% Lowercase alphabetical representation (a \ldots\ z aa \ldots\ zz)
%    \begin{macrocode}
\newcommand*{\@aaalph}[1]{%
  \@DT@loopN=#1\relax
  \advance\@DT@loopN by -1\relax
  \divide\@DT@loopN by 26\relax
  \@DT@modctr=\@DT@loopN
  \multiply\@DT@modctr by 26\relax
  \@DT@X=#1\relax
  \advance\@DT@X by -1\relax
  \advance\@DT@X by -\@DT@modctr
  \advance\@DT@loopN by 1\relax
  \advance\@DT@X by 1\relax
  \loop
    \@alph\@DT@X
    \advance\@DT@loopN by -1\relax
  \ifnum\@DT@loopN>0
  \repeat
}

\let\aaalphnum=\@aaalph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\AAAlphnum}
% Uppercase alphabetical representation (a \ldots\ z aa \ldots\ zz)
%    \begin{macrocode}
\newcommand*{\@AAAlph}[1]{%
  \@DT@loopN=#1\relax
  \advance\@DT@loopN by -1\relax
  \divide\@DT@loopN by 26\relax
  \@DT@modctr=\@DT@loopN
  \multiply\@DT@modctr by 26\relax
  \@DT@X=#1\relax
  \advance\@DT@X by -1\relax
  \advance\@DT@X by -\@DT@modctr
  \advance\@DT@loopN by 1\relax
  \advance\@DT@X by 1\relax
  \loop
    \@Alph\@DT@X
    \advance\@DT@loopN by -1\relax
  \ifnum\@DT@loopN>0
  \repeat
}

\let\AAAlphnum=\@AAAlph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\abalphnum}
% Lowercase alphabetical representation
%    \begin{macrocode}
\newcommand*{\@abalph}[1]{%
  \ifnum#1>17576\relax
    \PackageError{fmtcount}%
    {Value of counter too large for \protect\@abalph}%
    {Maximum value 17576}%
  \else
    \@DT@padzeroestrue
    \@strctr=17576\relax
    \@DT@X=#1\relax
    \advance\@DT@X by -1\relax
    \loop
      \@DT@modctr=\@DT@X
      \divide\@DT@modctr by \@strctr
      \ifthenelse{\boolean{@DT@padzeroes}
        \and \(\@DT@modctr=1\)}%
      {}{\@alph\@DT@modctr}%
      \ifnum\@DT@modctr=1\else\@DT@padzeroesfalse\fi
      \multiply\@DT@modctr by \@strctr
      \advance\@DT@X by -\@DT@modctr
      \divide\@strctr by 26\relax
    \ifnum\@strctr>1
    \repeat
    \advance\@DT@X by 1\relax
    \@alph\@DT@X
  \fi
}

\let\abalphnum=\@abalph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ABAlphnum}
% Uppercase alphabetical representation
%    \begin{macrocode}
\newcommand*{\@ABAlph}[1]{%
  \ifnum#1>17576\relax
    \PackageError{fmtcount}%
   {Value of counter too large for \protect\@ABAlph}%
   {Maximum value 17576}%
  \else
    \@DT@padzeroestrue
    \@strctr=17576\relax
    \@DT@X=#1\relax
    \advance\@DT@X by -1\relax
    \loop
      \@DT@modctr=\@DT@X
      \divide\@DT@modctr by \@strctr
      \ifthenelse{\boolean{@DT@padzeroes}\and
      \(\@DT@modctr=1\)}{}{\@Alph\@DT@modctr}%
      \ifnum\@DT@modctr=1\else\@DT@padzeroesfalse\fi
      \multiply\@DT@modctr by \@strctr
      \advance\@DT@X by -\@DT@modctr
      \divide\@strctr by 26\relax
    \ifnum\@strctr>1
    \repeat
    \advance\@DT@X by 1\relax
    \@Alph\@DT@X
  \fi
}

\let\ABAlphnum=\@ABAlph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@fmtc@count}
% Recursive command to count number of characters in argument.
% \cs{@strctr} should be set to zero before calling it.
%    \begin{macrocode}
\def\@fmtc@count#1#2\relax{%
  \if\relax#1%
  \else
    \advance\@strctr by 1\relax
    \@fmtc@count#2\relax
  \fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@decimal}
%\changes{1.31}{2009/10/02}{fixed unwanted space.}
% Format number as a decimal, possibly padded with zeroes in front.
%    \begin{macrocode}
\newcommand{\@decimal}[1]{%
  \@strctr=0\relax
  \expandafter\@fmtc@count\number#1\relax
  \@DT@loopN=\c@padzeroesN
  \advance\@DT@loopN by -\@strctr
  \ifnum\@DT@loopN>0\relax
    \@strctr=0\relax
    \whiledo{\@strctr < \@DT@loopN}{0\advance\@strctr by 1\relax}%
  \fi
  \number#1\relax
}

\let\decimalnum=\@decimal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\FCordinal}
%\begin{definition}
%\cs{FCordinal}\marg{number}
%\end{definition}
% This is a bit cumbersome.  Previously \cs{@ordinal}
% was defined in a similar way to \cs{abalph} etc.
% This ensured that the actual value of the counter was
% written in the new label stuff in the .aux file. However
% adding in an optional argument to determine the gender
% for multilingual compatibility messed things up somewhat.
% This was the only work around I could get to keep the
% the cross-referencing stuff working, which is why
% the optional argument comes \emph{after} the compulsory
% argument, instead of the usual manner of placing it before.
% Note however, that putting the optional argument means that
% any spaces will be ignored after the command if the optional
% argument is omitted.
% Version 1.04 changed \cs{ordinal} to \cs{FCordinal}
% to prevent it clashing with the memoir class. 
%    \begin{macrocode}
\newcommand{\FCordinal}[1]{%
  \expandafter\protect\expandafter\ordinalnum{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinal}
% If \cs{ordinal} isn't defined make \cs{ordinal} a synonym
% for \cs{FCordinal} to maintain compatibility with previous
% versions.
%    \begin{macrocode}
\@ifundefined{ordinal}
 {\let\ordinal\FCordinal}%
 {%
   \PackageWarning{fmtcount}%
   {\string\ordinal \space already defined use 
    \string\FCordinal \space instead.}
 }
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinalnum}
% Display ordinal where value is given as a number or 
% count register instead of a counter:
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\ordinalnum}[1]{%
  \new@ifnextchar[%
  {\@ordinalnum{#1}}%
  {\@ordinalnum{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@ordinalnum}
% Display ordinal according to gender (neuter added in v1.1,
% \cs{xspace} added in v1.2, and removed in v1.3\footnote{I
%couldn't get it to work consistently both with and without the
%optional argument}):
%    \begin{macrocode}
\def\@ordinalnum#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@ordinalF{#1}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@ordinalN{#1}{\@fc@ordstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
           {Invalid gender option `#2'}%
           {Available options are m, f or n}%
        }%
        \protect\@ordinalM{#1}{\@fc@ordstr}%
      }%
    }%
    \@fc@ordstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinal}
% Store the ordinal (first argument
% is identifying name, second argument is a counter.)
%    \begin{macrocode}
\newcommand*{\storeordinal}[2]{%
  \expandafter\protect\expandafter\storeordinalnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinalnum}
% Store ordinal (first argument
% is identifying name, second argument is a number or
% count register.)
%    \begin{macrocode}
\newcommand*{\storeordinalnum}[2]{%
  \@ifnextchar[%
  {\@storeordinalnum{#1}{#2}}%
  {\@storeordinalnum{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@storeordinalnum}
% Store ordinal according to gender:
%    \begin{macrocode}
\def\@storeordinalnum#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@ordinalF{#2}{\@fc@ord}
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@ordinalN{#2}{\@fc@ord}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m or f}%
      }%
      \protect\@ordinalM{#2}{\@fc@ord}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@ord
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\FMCuse}
% Get stored information:
%    \begin{macrocode}
\newcommand*{\FMCuse}[1]{\csname @fcs@#1\endcsname}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinalstring}
% Display ordinal as a string (argument is a counter)
%    \begin{macrocode}
\newcommand*{\ordinalstring}[1]{%
  \expandafter\protect\expandafter\ordinalstringnum{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinalstringnum}
% Display ordinal as a string (argument is a count register or
% number.)
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%\changes{1.33}{2009/10/15}{Made robust}
%    \begin{macrocode}
\newcommand{\ordinalstringnum}[1]{%
  \new@ifnextchar[%
  {\@ordinal@string{#1}}%
  {\@ordinal@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@ordinal@string}
% Display ordinal as a string according to gender.
%    \begin{macrocode}
\def\@ordinal@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@ordinalstringF{#1}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@ordinalstringN{#1}{\@fc@ordstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2' to \string\ordinalstring}%
          {Available options are m, f or f}%
        }%
        \protect\@ordinalstringM{#1}{\@fc@ordstr}%
      }%
    }%
    \@fc@ordstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinalstring}
% Store textual representation of number. First argument is 
% identifying name, second argument is the counter set to the 
% required number.
%    \begin{macrocode}
\newcommand*{\storeordinalstring}[2]{%
  \expandafter\protect\expandafter\storeordinalstringnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinalstringnum}
% Store textual representation of number. First argument is 
% identifying name, second argument is a count register or number.
%    \begin{macrocode}
\newcommand*{\storeordinalstringnum}[2]{%
  \@ifnextchar[%
  {\@store@ordinal@string{#1}{#2}}%
  {\@store@ordinal@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@ordinal@string}
% Store textual representation of number according to gender.
%    \begin{macrocode}
\def\@store@ordinal@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@ordinalstringF{#2}{\@fc@ordstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@ordinalstringN{#2}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3' to \string\ordinalstring}%
        {Available options are m, f or n}%
      }%
      \protect\@ordinalstringM{#2}{\@fc@ordstr}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@ordstr
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Ordinalstring}
% Display ordinal as a string with initial letters in upper case
% (argument is a counter)
%    \begin{macrocode}
\newcommand*{\Ordinalstring}[1]{%
  \expandafter\protect\expandafter\Ordinalstringnum{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Ordinalstringnum}
% Display ordinal as a string with initial letters in upper case
% (argument is a number or count register)
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\Ordinalstringnum}[1]{%
  \new@ifnextchar[%
  {\@Ordinal@string{#1}}%
  {\@Ordinal@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@Ordinal@string}
% Display ordinal as a string with initial letters in upper case
% according to gender
%    \begin{macrocode}
\def\@Ordinal@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@OrdinalstringF{#1}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@OrdinalstringN{#1}{\@fc@ordstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@OrdinalstringM{#1}{\@fc@ordstr}%
      }%
    }%
    \@fc@ordstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeOrdinalstring}
% Store textual representation of number, with initial letters in 
% upper case. First argument is identifying name, second argument 
% is the counter set to the 
% required number.
%    \begin{macrocode}
\newcommand*{\storeOrdinalstring}[2]{%
  \expandafter\protect\expandafter\storeOrdinalstringnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeOrdinalstringnum}
% Store textual representation of number, with initial letters in 
% upper case. First argument is identifying name, second argument 
% is a count register or number.
%    \begin{macrocode}
\newcommand*{\storeOrdinalstringnum}[2]{%
  \@ifnextchar[%
  {\@store@Ordinal@string{#1}{#2}}%
  {\@store@Ordinal@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@Ordinal@string}
% Store textual representation of number according to gender, 
% with initial letters in upper case.
%    \begin{macrocode}
\def\@store@Ordinal@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@OrdinalstringF{#2}{\@fc@ordstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@OrdinalstringN{#2}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m or f}%
      }%
      \protect\@OrdinalstringM{#2}{\@fc@ordstr}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@ordstr
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\storeORDINALstring}
% Store upper case textual representation of ordinal. The first 
% argument is identifying name, the second argument is a counter.
%    \begin{macrocode}
\newcommand*{\storeORDINALstring}[2]{%
  \expandafter\protect\expandafter\storeORDINALstringnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeORDINALstringnum}
% As above, but the second argument is a count register or a
% number.
%    \begin{macrocode}
\newcommand*{\storeORDINALstringnum}[2]{%
  \@ifnextchar[%
  {\@store@ORDINAL@string{#1}{#2}}%
  {\@store@ORDINAL@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@ORDINAL@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@store@ORDINAL@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@ordinalstringF{#2}{\@fc@ordstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@ordinalstringN{#2}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m or f}%
      }%
      \protect\@ordinalstringM{#2}{\@fc@ordstr}%
    }%
  }%
  \expandafter\edef\csname @fcs@#1\endcsname{%
    \noexpand\MakeUppercase{\@fc@ordstr}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ORDINALstring}
% Display upper case textual representation of an ordinal. The
% argument must be a counter.
%    \begin{macrocode}
\newcommand*{\ORDINALstring}[1]{%
  \expandafter\protect\expandafter\ORDINALstringnum{%
    \expandafter\the\csname c@#1\endcsname
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ORDINALstringnum}
% As above, but the argument is a count register or a number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\ORDINALstringnum}[1]{%
  \new@ifnextchar[%
  {\@ORDINAL@string{#1}}%
  {\@ORDINAL@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@ORDINAL@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@ORDINAL@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@ordinalstringF{#1}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@ordinalstringN{#1}{\@fc@ordstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@ordinalstringM{#1}{\@fc@ordstr}%
      }%
    }%
    \MakeUppercase{\@fc@ordstr}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storenumberstring}
% Convert number to textual respresentation, and store. First 
% argument is the identifying name, second argument is a counter 
% containing the number.
%    \begin{macrocode}
\newcommand*{\storenumberstring}[2]{%
  \expandafter\protect\expandafter\storenumberstringnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storenumberstringnum}
% As above, but second argument is a number or count register.
%    \begin{macrocode}
\newcommand{\storenumberstringnum}[2]{%
  \@ifnextchar[%
  {\@store@number@string{#1}{#2}}%
  {\@store@number@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@number@string}
% Gender is given as optional argument, \emph{at the end}.
%    \begin{macrocode}
\def\@store@number@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@numberstringF{#2}{\@fc@numstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@numberstringN{#2}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}
        {Invalid gender option `#3'}%
        {Available options are m, f or n}%
      }%
      \protect\@numberstringM{#2}{\@fc@numstr}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@numstr
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\numberstring}
% Display textual representation of a number. The argument
% must be a counter.
%    \begin{macrocode}
\newcommand*{\numberstring}[1]{%
  \expandafter\protect\expandafter\numberstringnum{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\numberstringnum}
% As above, but the argument is a count register or a number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\numberstringnum}[1]{%
  \new@ifnextchar[%
  {\@number@string{#1}}%
  {\@number@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\@number@string}
% Gender is specified as an optional argument \emph{at the end}.
%    \begin{macrocode}
\def\@number@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@numberstringF{#1}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
         \protect\@numberstringN{#1}{\@fc@numstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@numberstringM{#1}{\@fc@numstr}%
      }%
    }%
    \@fc@numstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNumberstring}
% Store textual representation of number. First argument is 
% identifying name, second argument is a counter.
%    \begin{macrocode}
\newcommand*{\storeNumberstring}[2]{%
  \expandafter\protect\expandafter\storeNumberstringnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNumberstringnum}
% As above, but second argument is a count register or number.
%    \begin{macrocode}
\newcommand{\storeNumberstringnum}[2]{%
  \@ifnextchar[%
  {\@store@Number@string{#1}{#2}}%
  {\@store@Number@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@Number@string}
% Gender is specified as an optional argument \emph{at the end}:
%    \begin{macrocode}
\def\@store@Number@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@NumberstringF{#2}{\@fc@numstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@NumberstringN{#2}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m, f or n}%
      }%
      \protect\@NumberstringM{#2}{\@fc@numstr}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@numstr
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Numberstring}
% Display textual representation of number. The argument must be
% a counter. 
%    \begin{macrocode}
\newcommand*{\Numberstring}[1]{%
  \expandafter\protect\expandafter\Numberstringnum{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Numberstringnum}
% As above, but the argument is a count register or number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\Numberstringnum}[1]{%
  \new@ifnextchar[%
  {\@Number@string{#1}}%
  {\@Number@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@Number@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@Number@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@NumberstringF{#1}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@NumberstringN{#1}{\@fc@numstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@NumberstringM{#1}{\@fc@numstr}%
      }%
    }%
    \@fc@numstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNUMBERstring}
% Store upper case textual representation of number. The first 
% argument is identifying name, the second argument is a counter.
%    \begin{macrocode}
\newcommand{\storeNUMBERstring}[2]{%
  \expandafter\protect\expandafter\storeNUMBERstringnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNUMBERstringnum}
% As above, but the second argument is a count register or a
% number.
%    \begin{macrocode}
\newcommand{\storeNUMBERstringnum}[2]{%
  \@ifnextchar[%
  {\@store@NUMBER@string{#1}{#2}}%
  {\@store@NUMBER@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@NUMBER@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@store@NUMBER@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@numberstringF{#2}{\@fc@numstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@numberstringN{#2}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m or f}%
      }%
      \protect\@numberstringM{#2}{\@fc@numstr}%
    }%
  }%
  \expandafter\edef\csname @fcs@#1\endcsname{%
    \noexpand\MakeUppercase{\@fc@numstr}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\NUMBERstring}
% Display upper case textual representation of a number. The
% argument must be a counter.
%    \begin{macrocode}
\newcommand*{\NUMBERstring}[1]{%
  \expandafter\protect\expandafter\NUMBERstringnum{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\NUMBERstringnum}
% As above, but the argument is a count register or a number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\NUMBERstringnum}[1]{%
  \new@ifnextchar[%
  {\@NUMBER@string{#1}}%
  {\@NUMBER@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@NUMBER@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@NUMBER@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@numberstringF{#1}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
         \protect\@numberstringN{#1}{\@fc@numstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@numberstringM{#1}{\@fc@numstr}%
      }%
    }%
    \MakeUppercase{\@fc@numstr}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\binary}
% Number representations in other bases. Binary:
%    \begin{macrocode}
\providecommand*{\binary}[1]{%
  \expandafter\protect\expandafter\@binary{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\aaalph}
% Like \ics{alph}, but goes beyond 26.
% (a \ldots\ z aa \ldots zz \ldots)
%    \begin{macrocode}
\providecommand*{\aaalph}[1]{%
  \expandafter\protect\expandafter\@aaalph{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\AAAlph}
% As before, but upper case.
%    \begin{macrocode}
\providecommand*{\AAAlph}[1]{%
  \expandafter\protect\expandafter\@AAAlph{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\abalph}
% Like \ics{alph}, but goes beyond 26. 
% (a \ldots\ z ab \ldots az \ldots)
%    \begin{macrocode}
\providecommand*{\abalph}[1]{%
  \expandafter\protect\expandafter\@abalph{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ABAlph}
% As above, but upper case.
%    \begin{macrocode}
\providecommand*{\ABAlph}[1]{%
  \expandafter\protect\expandafter\@ABAlph{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\hexadecimal}
% Hexadecimal:
%    \begin{macrocode}
\providecommand*{\hexadecimal}[1]{%
  \expandafter\protect\expandafter\@hexadecimal{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Hexadecimal}
% As above, but in upper case.
%    \begin{macrocode}
\providecommand*{\Hexadecimal}[1]{%
  \expandafter\protect\expandafter\@Hexadecimal{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\octal}
% Octal:
%    \begin{macrocode}
\providecommand*{\octal}[1]{%
  \expandafter\protect\expandafter\@octal{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\decimal}
% Decimal:
%    \begin{macrocode}
\providecommand*{\decimal}[1]{%
  \expandafter\protect\expandafter\@decimal{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%
%\subsection{Multilinguage Definitions}
%\begin{macro}{\@setdef@ultfmtcount}
% If multilingual support is provided, make \verb"\@numberstring" 
% etc use the correct language (if defined).
% Otherwise use English definitions. "\@setdef@ultfmtcount"
% sets the macros to use English.
%    \begin{macrocode}
\def\@setdef@ultfmtcount{%
  \@ifundefined{@ordinalMenglish}{\FCloadlang{english}}{}%
  \def\@ordinalstringM{\@ordinalstringMenglish}%
  \let\@ordinalstringF=\@ordinalstringMenglish
  \let\@ordinalstringN=\@ordinalstringMenglish
  \def\@OrdinalstringM{\@OrdinalstringMenglish}%
  \let\@OrdinalstringF=\@OrdinalstringMenglish
  \let\@OrdinalstringN=\@OrdinalstringMenglish
  \def\@numberstringM{\@numberstringMenglish}%
  \let\@numberstringF=\@numberstringMenglish
  \let\@numberstringN=\@numberstringMenglish
  \def\@NumberstringM{\@NumberstringMenglish}%
  \let\@NumberstringF=\@NumberstringMenglish
  \let\@NumberstringN=\@NumberstringMenglish
  \def\@ordinalM{\@ordinalMenglish}%
  \let\@ordinalF=\@ordinalM
  \let\@ordinalN=\@ordinalM
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\fc@multiling}
%changes{2.02}{2012-10-24}{new}
%\cs{fc@multiling}\marg{name}\marg{gender}
%    \begin{macrocode}
\newcommand*{\fc@multiling}[2]{%
  \ifcsundef{@#1#2\languagename}%
  {% try loading it
     \FCloadlang{\languagename}%
  }%
  {%
  }%
  \ifcsundef{@#1#2\languagename}%
  {%
    \PackageWarning{fmtcount}%
    {No support for \expandafter\string\csname#1\endcsname\space for
     language '\languagename'}%
    \ifthenelse{\equal{\languagename}{\fc@mainlang}}%
    {%
       \FCloadlang{english}%
    }%
    {%
    }%
    \ifcsdef{@#1#2\fc@mainlang}%
    {%
       \csuse{@#1#2\fc@mainlang}%
    }%
    {%
       \PackageWarningNoLine{fmtcount}%
       {No languages loaded at all! Loading english definitions}%
       \FCloadlang{english}%
       \def\fc@mainlang{english}%
       \csuse{@#1#2english}%
    }%
  }%
  {%
    \csuse{@#1#2\languagename}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@set@mulitling@fmtcount}
% This defines the number and ordinal string macros to use 
% \cs{languagename}:
%\changes{2.0}{2012-06-18}{changed errors to warnings for
%unsupported languages}
%    \begin{macrocode}
\def\@set@mulitling@fmtcount{%
%    \end{macrocode}
% The masculine version of \cs{numberstring}:
%    \begin{macrocode}
  \def\@numberstringM{%
    \fc@multiling{numberstring}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{numberstring}:
%    \begin{macrocode}
  \def\@numberstringF{%
    \fc@multiling{numberstring}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{numberstring}:
%    \begin{macrocode}
  \def\@numberstringN{%
    \fc@multiling{numberstring}{N}%
  }%
%    \end{macrocode}
% The masculine version of \cs{Numberstring}:
%    \begin{macrocode}
  \def\@NumberstringM{%
    \fc@multiling{Numberstring}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{Numberstring}:
%    \begin{macrocode}
  \def\@NumberstringF{%
    \fc@multiling{Numberstring}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{Numberstring}:
%    \begin{macrocode}
  \def\@NumberstringN{%
    \fc@multiling{Numberstring}{N}%
  }%
%    \end{macrocode}
% The masculine version of \cs{ordinal}:
%    \begin{macrocode}
  \def\@ordinalM{%
    \fc@multiling{ordinal}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{ordinal}:
%    \begin{macrocode}
  \def\@ordinalF{%
    \fc@multiling{ordinal}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{ordinal}:
%    \begin{macrocode}
  \def\@ordinalN{%
    \fc@multiling{ordinal}{N}%
  }%
%    \end{macrocode}
% The masculine version of \cs{ordinalstring}:
%    \begin{macrocode}
  \def\@ordinalstringM{%
    \fc@multiling{ordinalstring}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{ordinalstring}:
%    \begin{macrocode}
  \def\@ordinalstringF{%
    \fc@multiling{ordinalstring}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{ordinalstring}:
%    \begin{macrocode}
  \def\@ordinalstringN{%
    \fc@multiling{ordinalstring}{N}%
  }%
%    \end{macrocode}
% The masculine version of \cs{Ordinalstring}:
%    \begin{macrocode}
  \def\@OrdinalstringM{%
    \fc@multiling{Ordinalstring}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{Ordinalstring}:
%    \begin{macrocode}
  \def\@OrdinalstringF{%
    \fc@multiling{Ordinalstring}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{Ordinalstring}:
%    \begin{macrocode}
  \def\@OrdinalstringN{%
    \fc@multiling{Ordinalstring}{N}%
  }%
}
%    \end{macrocode}
%\end{macro}
% Check to see if babel or ngerman packages have been loaded.
%    \begin{macrocode}
\@ifpackageloaded{babel}%
{%
  \@set@mulitling@fmtcount
}%
{%
  \@ifpackageloaded{ngerman}%
  {%
    \FCloadlang{ngerman}%
    \@set@mulitling@fmtcount
  }%
  {%
    \@setdef@ultfmtcount
  }%
}
%    \end{macrocode}
% Backwards compatibility:
%    \begin{macrocode}
\let\@ordinal=\@ordinalM
\let\@ordinalstring=\@ordinalstringM
\let\@Ordinalstring=\@OrdinalstringM
\let\@numberstring=\@numberstringM
\let\@Numberstring=\@NumberstringM
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fmtcount.sty>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-american.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-american.def}
% American English definitions
%    \begin{macrocode}
\ProvidesFCLanguage{american}[2012/06/18]
%    \end{macrocode}
% Loaded fc-USenglish.def if not already loaded
%    \begin{macrocode}
\FCloadlang{USenglish}
%    \end{macrocode}
% These are all just synonyms for the commands provided by
% fc-USenglish.def.
%    \begin{macrocode}
\let\@ordinalMamerican\@ordinalMUSenglish
\let\@ordinalFamerican\@ordinalMUSenglish
\let\@ordinalNamerican\@ordinalMUSenglish
\let\@numberstringMamerican\@numberstringMUSenglish
\let\@numberstringFamerican\@numberstringMUSenglish
\let\@numberstringNamerican\@numberstringMUSenglish
\let\@NumberstringMamerican\@NumberstringMUSenglish
\let\@NumberstringFamerican\@NumberstringMUSenglish
\let\@NumberstringNamerican\@NumberstringMUSenglish
\let\@ordinalstringMamerican\@ordinalstringMUSenglish
\let\@ordinalstringFamerican\@ordinalstringMUSenglish
\let\@ordinalstringNamerican\@ordinalstringMUSenglish
\let\@OrdinalstringMamerican\@OrdinalstringMUSenglish
\let\@OrdinalstringFamerican\@OrdinalstringMUSenglish
\let\@OrdinalstringNamerican\@OrdinalstringMUSenglish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-american.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-british.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-british.def}
% British definitions
%    \begin{macrocode}
\ProvidesFCLanguage{british}[2012/06/18]
%    \end{macrocode}
% Load fc-english.def, if not already loaded
%    \begin{macrocode}
\FCloadlang{english}
%    \end{macrocode}
% These are all just synonyms for the commands provided by
% fc-english.def.
%    \begin{macrocode}
\let\@ordinalMbritish\@ordinalMenglish
\let\@ordinalFbritish\@ordinalMenglish
\let\@ordinalNbritish\@ordinalMenglish
\let\@numberstringMbritish\@numberstringMenglish
\let\@numberstringFbritish\@numberstringMenglish
\let\@numberstringNbritish\@numberstringMenglish
\let\@NumberstringMbritish\@NumberstringMenglish
\let\@NumberstringFbritish\@NumberstringMenglish
\let\@NumberstringNbritish\@NumberstringMenglish
\let\@ordinalstringMbritish\@ordinalstringMenglish
\let\@ordinalstringFbritish\@ordinalstringMenglish
\let\@ordinalstringNbritish\@ordinalstringMenglish
\let\@OrdinalstringMbritish\@OrdinalstringMenglish
\let\@OrdinalstringFbritish\@OrdinalstringMenglish
\let\@OrdinalstringNbritish\@OrdinalstringMenglish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-british.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-english.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-english.def}
% English definitions
%    \begin{macrocode}
\ProvidesFCLanguage{english}[2012/06/18]
%    \end{macrocode}
% Define macro that converts a number or count register (first 
% argument) to an ordinal, and stores the result in the 
% second argument, which should be a control sequence.
%    \begin{macrocode}
\newcommand*{\@ordinalMenglish}[2]{%
\def\@fc@ord{}%
\@orgargctr=#1\relax
\@ordinalctr=#1%
\@modulo{\@ordinalctr}{100}%
\ifnum\@ordinalctr=11\relax
  \def\@fc@ord{th}%
\else
  \ifnum\@ordinalctr=12\relax
    \def\@fc@ord{th}%
  \else
    \ifnum\@ordinalctr=13\relax
      \def\@fc@ord{th}%
    \else
      \@modulo{\@ordinalctr}{10}%
      \ifcase\@ordinalctr
        \def\@fc@ord{th}%      case 0
        \or \def\@fc@ord{st}%  case 1
        \or \def\@fc@ord{nd}%  case 2
        \or \def\@fc@ord{rd}%  case 3
      \else
        \def\@fc@ord{th}%      default case
      \fi
    \fi
  \fi
\fi
\edef#2{\number#1\relax\noexpand\fmtord{\@fc@ord}}%
}
%    \end{macrocode}
% There is no gender difference in English, so make feminine and
% neuter the same as the masculine.
%    \begin{macrocode}
\let\@ordinalFenglish=\@ordinalMenglish
\let\@ordinalNenglish=\@ordinalMenglish
%    \end{macrocode}
% Define the macro that prints the value of a \TeX\ count register
% as text. To make it easier, break it up into units, teens and
% tens. First, the units: the argument should be between 0 and 9
% inclusive.
%    \begin{macrocode}
\newcommand*{\@@unitstringenglish}[1]{%
\ifcase#1\relax
zero%
\or one%
\or two%
\or three%
\or four%
\or five%
\or six%
\or seven%
\or eight%
\or nine%
\fi
}
%    \end{macrocode}
% Next the tens, again the argument should be between 0 and 9
% inclusive.
%    \begin{macrocode}
\newcommand*{\@@tenstringenglish}[1]{%
\ifcase#1\relax
\or ten%
\or twenty%
\or thirty%
\or forty%
\or fifty%
\or sixty%
\or seventy%
\or eighty%
\or ninety%
\fi
}
%    \end{macrocode}
% Finally the teens, again the argument should be between 0 and 9
% inclusive.
%    \begin{macrocode}
\newcommand*{\@@teenstringenglish}[1]{%
\ifcase#1\relax
ten%
\or eleven%
\or twelve%
\or thirteen%
\or fourteen%
\or fifteen%
\or sixteen%
\or seventeen%
\or eighteen%
\or nineteen%
\fi
}
%    \end{macrocode}
% As above, but with the initial letter in uppercase. The units:
%    \begin{macrocode}
\newcommand*{\@@Unitstringenglish}[1]{%
\ifcase#1\relax
Zero%
\or One%
\or Two%
\or Three%
\or Four%
\or Five%
\or Six%
\or Seven%
\or Eight%
\or Nine%
\fi
}
%    \end{macrocode}
% The tens:
%    \begin{macrocode}
\newcommand*{\@@Tenstringenglish}[1]{%
\ifcase#1\relax
\or Ten%
\or Twenty%
\or Thirty%
\or Forty%
\or Fifty%
\or Sixty%
\or Seventy%
\or Eighty%
\or Ninety%
\fi
}
%    \end{macrocode}
% The teens:
%    \begin{macrocode}
\newcommand*{\@@Teenstringenglish}[1]{%
\ifcase#1\relax
Ten%
\or Eleven%
\or Twelve%
\or Thirteen%
\or Fourteen%
\or Fifteen%
\or Sixteen%
\or Seventeen%
\or Eighteen%
\or Nineteen%
\fi
}
%    \end{macrocode}
% This has changed in version 1.09, so that it now stores
% the result in the second argument, but doesn't display anything.
% Since it only affects internal macros, it shouldn't affect
% documents created with older versions. (These internal macros are
% not meant for use in documents.)
%    \begin{macrocode}
\newcommand*{\@@numberstringenglish}[2]{%
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9
  \divide\@strctr by 10
  \ifnum\@strctr>1\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
    \@strctr=#1 \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \ifnum\@strctr>0\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr-\@unitstring{\@strctr}}%
    \fi
  \else
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\ \@thousand}%
\else
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ \@thousand}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{1000}%
\divide\@strctr by 100
\ifnum\@strctr>0\relax
   \ifnum#1>1000\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\ }%
   \fi
   \let\@@fc@numstr#2\relax
   \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ \@hundred}%
\fi
\@strctr=#1\relax \@modulo{\@strctr}{100}%
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ \@andname\ }%
  \fi
\fi
\ifnum\@strctr>19\relax
  \divide\@strctr by 10\relax
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
  \@strctr=#1\relax \@modulo{\@strctr}{10}%
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr-\@unitstring{\@strctr}}%
  \fi
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
       \ifnum#1<100\relax
          \let\@@fc@numstr#2\relax
          \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
       \fi
    \else
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
    \fi
  \else
    \@modulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
\fi
}
%    \end{macrocode}
% All lower case version, the second argument must be a 
% control sequence.
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMenglish}[2]{%
\let\@unitstring=\@@unitstringenglish
\let\@teenstring=\@@teenstringenglish
\let\@tenstring=\@@tenstringenglish
\def\@hundred{hundred}\def\@thousand{thousand}%
\def\@andname{and}%
\@@numberstringenglish{#1}{#2}%
}
%    \end{macrocode}
% There is no gender in English, so make feminine and neuter the
% same
% as the masculine.
%    \begin{macrocode}
\let\@numberstringFenglish=\@numberstringMenglish
\let\@numberstringNenglish=\@numberstringMenglish
%    \end{macrocode}
% This version makes the first letter of each word an uppercase
% character (except ``and''). The second argument must be a control 
% sequence.
%    \begin{macrocode}
\newcommand*{\@NumberstringMenglish}[2]{%
\let\@unitstring=\@@Unitstringenglish
\let\@teenstring=\@@Teenstringenglish
\let\@tenstring=\@@Tenstringenglish
\def\@hundred{Hundred}\def\@thousand{Thousand}%
\def\@andname{and}%
\@@numberstringenglish{#1}{#2}}
%    \end{macrocode}
% There is no gender in English, so make feminine and neuter the
% same
% as the masculine.
%    \begin{macrocode}
\let\@NumberstringFenglish=\@NumberstringMenglish
\let\@NumberstringNenglish=\@NumberstringMenglish
%    \end{macrocode}
% Define a macro that produces an ordinal as a string. Again, break
% it up into units, teens and tens. First the units:
%    \begin{macrocode}
\newcommand*{\@@unitthstringenglish}[1]{%
\ifcase#1\relax
zeroth%
\or first%
\or second%
\or third%
\or fourth%
\or fifth%
\or sixth%
\or seventh%
\or eighth%
\or ninth%
\fi
}
%    \end{macrocode}
% Next the tens:
%    \begin{macrocode}
\newcommand*{\@@tenthstringenglish}[1]{%
\ifcase#1\relax
\or tenth%
\or twentieth%
\or thirtieth%
\or fortieth%
\or fiftieth%
\or sixtieth%
\or seventieth%
\or eightieth%
\or ninetieth%
\fi
}
%    \end{macrocode}
% The teens:
%    \begin{macrocode}
\newcommand*{\@@teenthstringenglish}[1]{%
\ifcase#1\relax
tenth%
\or eleventh%
\or twelfth%
\or thirteenth%
\or fourteenth%
\or fifteenth%
\or sixteenth%
\or seventeenth%
\or eighteenth%
\or nineteenth%
\fi
}
%    \end{macrocode}
% As before, but with the first letter in upper case. The units:
%    \begin{macrocode}
\newcommand*{\@@Unitthstringenglish}[1]{%
\ifcase#1\relax
Zeroth%
\or First%
\or Second%
\or Third%
\or Fourth%
\or Fifth%
\or Sixth%
\or Seventh%
\or Eighth%
\or Ninth%
\fi
}
%    \end{macrocode}
% The tens:
%    \begin{macrocode}
\newcommand*{\@@Tenthstringenglish}[1]{%
\ifcase#1\relax
\or Tenth%
\or Twentieth%
\or Thirtieth%
\or Fortieth%
\or Fiftieth%
\or Sixtieth%
\or Seventieth%
\or Eightieth%
\or Ninetieth%
\fi
}
%    \end{macrocode}
% The teens:
%    \begin{macrocode}
\newcommand*{\@@Teenthstringenglish}[1]{%
\ifcase#1\relax
Tenth%
\or Eleventh%
\or Twelfth%
\or Thirteenth%
\or Fourteenth%
\or Fifteenth%
\or Sixteenth%
\or Seventeenth%
\or Eighteenth%
\or Nineteenth%
\fi
}
%    \end{macrocode}
% Again, as from version 1.09, this has been changed to take two
% arguments, where the second argument is a control sequence.
% The resulting text is stored in the control sequence, and nothing
% is displayed.
%    \begin{macrocode}
\newcommand*{\@@ordinalstringenglish}[2]{%
\@strctr=#1\relax
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000 (value given: \number\@strctr)}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\fi
\def#2{}%
\fi
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9\relax
%    \end{macrocode}
% \#1 is greater or equal to 10000
%    \begin{macrocode}
  \divide\@strctr by 10
  \ifnum\@strctr>1\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@tenstring{\@strctr}}%
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \ifnum\@strctr>0\relax
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr-\@unitstring{\@strctr}}%
    \fi
  \else
    \@strctr=#1\relax \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@teenstring{\@strctr}}%
  \fi
  \@strctr=#1\relax \@modulo{\@strctr}{1000}%
  \ifnum\@strctr=0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@thousandth}%
  \else
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@thousand}%
  \fi
\else
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
    \@strctr=#1\relax \@modulo{\@strctr}{1000}%
    \let\@@fc@ordstr#2\relax
    \ifnum\@strctr=0\relax
      \edef#2{\@@fc@ordstr\ \@thousandth}%
    \else
      \edef#2{\@@fc@ordstr\ \@thousand}%
    \fi
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{1000}%
\divide\@strctr by 100
\ifnum\@strctr>0\relax
  \ifnum#1>1000\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ }%
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
  \@strctr=#1\relax \@modulo{\@strctr}{100}%
  \let\@@fc@ordstr#2\relax
  \ifnum\@strctr=0\relax
    \edef#2{\@@fc@ordstr\ \@hundredth}%
  \else
    \edef#2{\@@fc@ordstr\ \@hundred}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{100}%
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@andname\ }%
  \fi
\fi
\ifnum\@strctr>19\relax
  \@tmpstrctr=\@strctr
  \divide\@strctr by 10\relax
  \@modulo{\@tmpstrctr}{10}%
  \let\@@fc@ordstr#2\relax
  \ifnum\@tmpstrctr=0\relax
    \edef#2{\@@fc@ordstr\@tenthstring{\@strctr}}%
  \else
    \edef#2{\@@fc@ordstr\@tenstring{\@strctr}}%
  \fi
  \@strctr=#1\relax \@modulo{\@strctr}{10}%
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr-\@unitthstring{\@strctr}}%
  \fi
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
      \ifnum#1<100\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
      \fi
    \else
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
    \fi
  \else
    \@modulo{\@strctr}{10}%
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@teenthstring{\@strctr}}%
  \fi
\fi
}
%    \end{macrocode}
% All lower case version. Again, the second argument must be a
% control sequence in which the resulting text is stored.
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMenglish}[2]{%
\let\@unitthstring=\@@unitthstringenglish
\let\@teenthstring=\@@teenthstringenglish
\let\@tenthstring=\@@tenthstringenglish
\let\@unitstring=\@@unitstringenglish
\let\@teenstring=\@@teenstringenglish
\let\@tenstring=\@@tenstringenglish
\def\@andname{and}%
\def\@hundred{hundred}\def\@thousand{thousand}%
\def\@hundredth{hundredth}\def\@thousandth{thousandth}%
\@@ordinalstringenglish{#1}{#2}}
%    \end{macrocode}
% No gender in English, so make feminine and neuter same as
% masculine:
%    \begin{macrocode}
\let\@ordinalstringFenglish=\@ordinalstringMenglish
\let\@ordinalstringNenglish=\@ordinalstringMenglish
%    \end{macrocode}
% First letter of each word in upper case:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMenglish}[2]{%
\let\@unitthstring=\@@Unitthstringenglish
\let\@teenthstring=\@@Teenthstringenglish
\let\@tenthstring=\@@Tenthstringenglish
\let\@unitstring=\@@Unitstringenglish
\let\@teenstring=\@@Teenstringenglish
\let\@tenstring=\@@Tenstringenglish
\def\@andname{and}%
\def\@hundred{Hundred}\def\@thousand{Thousand}%
\def\@hundredth{Hundredth}\def\@thousandth{Thousandth}%
\@@ordinalstringenglish{#1}{#2}}
%    \end{macrocode}
% No gender in English, so make feminine and neuter same as
% masculine:
%    \begin{macrocode}
\let\@OrdinalstringFenglish=\@OrdinalstringMenglish
\let\@OrdinalstringNenglish=\@OrdinalstringMenglish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-english.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-francais.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-francais.def}
%    \begin{macrocode}
\ProvidesFCLanguage{francais}[2012/06/18]
\FCloadlang{french}
%    \end{macrocode}
% Set |francais| to be equivalent to |french|.
%    \begin{macrocode}
\let\@ordinalMfrancais=\@ordinalMfrench
\let\@ordinalFfrancais=\@ordinalFfrench
\let\@ordinalNfrancais=\@ordinalNfrench
\let\@numberstringMfrancais=\@numberstringMfrench
\let\@numberstringFfrancais=\@numberstringFfrench
\let\@numberstringNfrancais=\@numberstringNfrench
\let\@NumberstringMfrancais=\@NumberstringMfrench
\let\@NumberstringFfrancais=\@NumberstringFfrench
\let\@NumberstringNfrancais=\@NumberstringNfrench
\let\@ordinalstringMfrancais=\@ordinalstringMfrench
\let\@ordinalstringFfrancais=\@ordinalstringFfrench
\let\@ordinalstringNfrancais=\@ordinalstringNfrench
\let\@OrdinalstringMfrancais=\@OrdinalstringMfrench
\let\@OrdinalstringFfrancais=\@OrdinalstringFfrench
\let\@OrdinalstringNfrancais=\@OrdinalstringNfrench
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-francais.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-french.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-french.def}
% Definitions for French.
%    \begin{macrocode}
\ProvidesFCLanguage{french}[2012/10/24]
%    \end{macrocode}
% Package \styfmt{fcprefix} is needed to format the prefix \meta{$n$} in \meta{$n$}illion or
% \meta{$n$}illiard.  Big numbers were developped based reference:
% \uref{http://www.alain.be/boece/noms\_de\_nombre.html}
% (Package now loaded by \sty{fmtcount})
%
% Options for controlling plural mark. First of all we define some temporary macro \cs{fc@french@set@plural}
% in order to factorize code that defines an plural mark option:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&key name,\\
% \#2&key value,\\
% \#3&configuration index for `\texttt{reformed}', \\
% \#4&configuration index for `\texttt{traditional}',\\
% \#5&configuration index for `\texttt{reformed o}', and\\
% \#6&configuration index for `\texttt{traditional o}'.
% \end{tabularx}
%    \begin{macrocode}
\def\fc@french@set@plural#1#2#3#4#5#6{%
  \ifthenelse{\equal{#2}{reformed}}{%
    \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{#3}%
  }{%
    \ifthenelse{\equal{#2}{traditional}}{%
      \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{#4}%
    }{%
      \ifthenelse{\equal{#2}{reformed o}}{%
        \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{#5}%
      }{%
        \ifthenelse{\equal{#2}{traditional o}}{%
          \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{#6}%
        }{%
          \ifthenelse{\equal{#2}{always}}{%
            \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{0}%
          }{%
            \ifthenelse{\equal{#2}{never}}{%
              \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{1}%
            }{%
              \ifthenelse{\equal{#2}{multiple}}{%
                \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{2}%
              }{%
                \ifthenelse{\equal{#2}{multiple g-last}}{%
                  \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{3}%
                }{%
                  \ifthenelse{\equal{#2}{multiple l-last}}{%
                    \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{4}%
                  }{%
                    \ifthenelse{\equal{#2}{multiple lng-last}}{%
                      \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{5}%
                    }{%
                      \ifthenelse{\equal{#2}{multiple ng-last}}{%
                        \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{6}%
                      }{%
                        \PackageError{fmtcount}{Unexpected argument}{%
                          `#2' was unexpected: french option `#1 plural' expects `reformed', `traditional',
                          `reformed o', `traditional o', `always', `never', `multiple', `multiple g-last',
                          `multiple l-last', `multiple lng-last', or `multiple ng-last'.%
                        }}}}}}}}}}}}}
%    \end{macrocode}
% Now a shorthand \cs{@tempa} is defined just to define all the options controlling plural mark. This
% shorthand takes into account that `\texttt{reformed}' and `\texttt{traditional}' have the same effect, and
% so do `\texttt{reformed o}' and `\texttt{traditional o}'.
%    \begin{macrocode}
\def\@tempa#1#2#3{%
  \define@key{fcfrench}{#1 plural}[reformed]{%
    \fc@french@set@plural{#1}{##1}{#2}{#2}{#3}{#3}%
  }%
}
\@tempa{vingt}{4}{5}
\@tempa{cent}{4}{5}
\@tempa{mil}{0}{0}
\@tempa{n-illion}{2}{6}
\@tempa{n-illiard}{2}{6}
%    \end{macrocode}
% For option `\texttt{all plural}' we cannot use the \cs{@tempa} shorthand, because `\texttt{all plural}'
% is just a multiplexer.
%    \begin{macrocode}
\define@key{fcfrench}{all plural}[reformed]{%
  \csname KV@fcfrench@vingt plural\endcsname{#1}%
  \csname KV@fcfrench@cent plural\endcsname{#1}%
  \csname KV@fcfrench@mil plural\endcsname{#1}%
  \csname KV@fcfrench@n-illion plural\endcsname{#1}%
  \csname KV@fcfrench@n-illiard plural\endcsname{#1}%
}
%    \end{macrocode}
% Now options `\texttt{dash or space}', we have three possible key values:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% traditional& use dash for numbers below 100, except when `et' is used, and space otherwise\\
% reformed& reform of 1990, use dash except with million \& milliard, and suchlikes,
%   i.e. \meta{$n$}illion and \meta{$n$}illiard,\\
% always& always use dashes to separate all words
% \end{tabularx}
%    \begin{macrocode}
\define@key{fcfrench}{dash or space}[reformed]{%
  \ifthenelse{\equal{#1}{traditional}}{%
    \let\fc@frenchoptions@supermillion@dos\space%
    \let\fc@frenchoptions@submillion@dos\space
  }{%
    \ifthenelse{\equal{#1}{reformed}\or\equal{#1}{1990}}{%
      \let\fc@frenchoptions@supermillion@dos\space
      \def\fc@frenchoptions@submillion@dos{-}%
    }{%
      \ifthenelse{\equal{#1}{always}}{%
        \def\fc@frenchoptions@supermillion@dos{-}%
        \def\fc@frenchoptions@submillion@dos{-}%
      }{%
        \PackageError{fmtcount}{Unexpected argument}{%
          French option `dash or space' expects `always', `reformed' or `traditional'
        }
      }%
    }%
  }%
}
%    \end{macrocode}
% Option `\texttt{scale}', can take 3 possible values:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%  long& for which \meta{\(n\)}illions \& \meta{\(n\)}illiards are used with \(10^{6\times n} = 1
%   \textrm{\meta{$n$}}illion\), and \(10^{6\times n+3} = 1 \textrm{\meta{$n$}}illiard\)\\
% short& for which \meta{$n$}illions only are used with \(10^{3\times n+3} = 1
%   \textrm{\meta{$n$}illion}\)\\
% recursive& for which \(10^{18} = \textrm{un milliard de milliards}\)
% \end{tabularx}
%    \begin{macrocode}
\define@key{fcfrench}{scale}[recursive]{%
  \ifthenelse{\equal{#1}{long}}{%
      \let\fc@poweroften\fc@@pot@longscalefrench
  }{%
    \ifthenelse{\equal{#1}{recursive}}{%
      \let\fc@poweroften\fc@@pot@recursivefrench
    }{%
      \ifthenelse{\equal{#1}{short}}{%
        \let\fc@poweroften\fc@@pot@shortscalefrench
      }{%
        \PackageError{fmtcount}{Unexpected argument}{%
          French option `scale' expects `long', `recursive' or `short'
        }
      }%
    }%
  }%
}
%    \end{macrocode}
% Option `\texttt{n-illiard upto}' is ignored if `\texttt{scale}' is different from `\texttt{long}'. It can
% take the following values:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% infinity&in that case \meta{$n$}illard are never disabled,\\
% infty&this is just a shorthand for `\texttt{infinity}', and\\
% \textrm{\(n\)}& any integer that is such that \(n>0\), and that \(\forall k\in\mathbb{N}, k\geq n\),
%   number \(10^{6\times k+3}\) will be formatted as ``mille \meta{$n$}illions''
% \end{tabularx}
%    \begin{macrocode}
\define@key{fcfrench}{n-illiard upto}[infinity]{%
  \ifthenelse{\equal{#1}{infinity}}{%
      \def\fc@longscale@nilliard@upto{0}%
  }{%
    \ifthenelse{\equal{#1}{infty}}{%
      \def\fc@longscale@nilliard@upto{0}%
    }{%
      \if Q\ifnum9<1#1Q\fi\else
      \PackageError{fmtcount}{Unexpected argument}{%
        French option `milliard threshold' expects `infinity', or equivalently `infty', or a non negative
        integer.}%
      \fi
      \def\fc@longscale@nilliard@upto{#1}%
    }}%
}
%    \end{macrocode}
% Now, the options `\texttt{france}', `\texttt{swiss}' and `\texttt{belgian}' are defined to select the
% dialect to use. Macro \cs{@tempa} is just a local shorthand to define each one of this option.
%    \begin{macrocode}
\def\@tempa#1{%
  \define@key{fcfrench}{#1}[]{%
    \PackageError{fmtcount}{Unexpected argument}{French option with key `#1' does not take
      any value}}%
  \expandafter\def\csname KV@fcfrench@#1@default\endcsname{%
    \def\fmtcount@french{#1}}%
}%
\@tempa{france}\@tempa{swiss}\@tempa{belgian}%
%    \end{macrocode}
% Now, option `\texttt{dialect}' is now defined so that `\texttt{france}', `\texttt{swiss}' and
% `\texttt{belgian}' can also be used as key values, which is more conventional although less concise.
%    \begin{macrocode}
\define@key{fcfrench}{dialect}[france]{%
  \ifthenelse{\equal{#1}{france}
    \or\equal{#1}{swiss}
    \or\equal{#1}{belgian}}{%
    \def\fmtcount@french{#1}}{%
    \PackageError{fmtcount}{Invalid value `#1' to french option dialect key}
    {Option `french' can only take the values `france',
      `belgian' or `swiss'}}}
%    \end{macrocode}
% The option \texttt{mil plural mark} allows to make the plural of \texttt{mil} to be regular,
% i.e. \texttt{mils}, instead of \texttt{mille}. By default it is `\texttt{le}'.
%    \begin{macrocode}
\define@key{fcfrench}{mil plural mark}[le]{%
  \def\fc@frenchoptions@mil@plural@mark{#1}}
%    \end{macrocode}
% Definition of case handling macros. This should be moved somewhere else to be commonalized between all
% languages.
%    \begin{macrocode}
\def\fc@UpperCaseFirstLetter#1#2\@nil{%
  \uppercase{#1}#2}

\def\fc@CaseIden#1\@nil{%
  #1%
}
\def\fc@UpperCaseAll#1\@nil{%
  \uppercase{#1}%
}

\let\fc@case\fc@CaseIden

%    \end{macrocode}
% \DescribeMacro\@ordinalMfrench
%    \begin{macrocode}
\newcommand*{\@ordinalMfrench}[2]{%
\iffmtord@abbrv
  \edef#2{\number#1\relax\noexpand\fmtord{e}}%
\else
  \ifnum#1=1\relax
    \edef#2{\number#1\relax\noexpand\fmtord{er}}%
  \else
    \edef#2{\number#1\relax\noexpand\fmtord{eme}}%
  \fi
\fi}
%    \end{macrocode}
% \DescribeMacro\@ordinalFfrench
%    \begin{macrocode}
\newcommand*{\@ordinalFfrench}[2]{%
\iffmtord@abbrv
  \edef#2{\number#1\relax\noexpand\fmtord{e}}%
\else
  \ifnum#1=1 %
     \edef#2{\number#1\relax\noexpand\fmtord{i\`ere}}%
  \else
     \edef#2{\number#1\relax\noexpand\fmtord{i\`eme}}%
  \fi
\fi}
%    \end{macrocode}
% In French neutral gender and masculine gender are formally identical.
%    \begin{macrocode}
\let\@ordinalNfrench\@ordinalMfrench
%    \end{macrocode}
% \DescribeMacro\@@unitstringfrench
%    \begin{macrocode}
\newcommand*{\@@unitstringfrench}[1]{%
\noexpand\fc@case
\ifcase#1 %
z\'ero%
\or un%
\or deux%
\or trois%
\or quatre%
\or cinq%
\or six%
\or sept%
\or huit%
\or neuf%
\fi
\noexpand\@nil
}
%    \end{macrocode}
% \DescribeMacro\@@tenstringfrench
%    \begin{macrocode}
\newcommand*{\@@tenstringfrench}[1]{%
\noexpand\fc@case
\ifcase#1 %
\or dix%
\or vingt%
\or trente%
\or quarante%
\or cinquante%
\or soixante%
\or septante%
\or huitante%
\or nonante%
\or cent%
\fi
\noexpand\@nil
}
%    \end{macrocode}
% \DescribeMacro\@@teenstringfrench
%    \begin{macrocode}
\newcommand*{\@@teenstringfrench}[1]{%
\noexpand\fc@case
\ifcase#1 %
    dix%
\or onze%
\or douze%
\or treize%
\or quatorze%
\or quinze%
\or seize%
\or dix\noexpand\@nil-\noexpand\fc@case sept%
\or dix\noexpand\@nil-\noexpand\fc@case huit%
\or dix\noexpand\@nil-\noexpand\fc@case neuf%
\fi
\noexpand\@nil
}
%    \end{macrocode}
% \DescribeMacro\@@seventiesfrench
%    \begin{macrocode}
\newcommand*{\@@seventiesfrench}[1]{%
\@tenstring{6}%
\ifnum#1=1 %
\fc@frenchoptions@submillion@dos\@andname\fc@frenchoptions@submillion@dos
\else
-%
\fi
\@teenstring{#1}%
}
%    \end{macrocode}
% \DescribeMacro\@@eightiesfrench Macro \cs{@@eightiesfrench} is used to format numbers in the interval
% \([80\intv 89]\). Argument as follows:\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#1&digit \(d_{w}\) such that the number to be formatted is \(80 + d_{w}\)\\
% \end{tabularx}
% Implicit arguments as:\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \cs{count0}&weight \(w\) of the number \(d_{w+1}d_{w}\) to be formatted\\
%   \cs{count1}&same as \cs{\#1}\\
%   \cs{count6}&input, counter giving the least weight of non zero digits in top level formatted number
%   integral part, with rounding down to a multiple of 3,\\
%   \cs{count9}&input, counter giving the power type of the power of ten following the eighties to be
%   formatted; that is `1' for ``mil'' and `2' for ``\meta{$n$}illion\textbar \meta{$n$}illiard''.
% \end{tabularx}
%    \begin{macrocode}
\newcommand*\@@eightiesfrench[1]{%
\fc@case quatre\@nil-\noexpand\fc@case vingt%
\ifnum#1>0 %
  \ifnum\fc@frenchoptions@vingt@plural=0 % vingt plural=always
  s%
  \fi
  \noexpand\@nil
  -\@unitstring{#1}%
\else
  \ifcase\fc@frenchoptions@vingt@plural\space
    s% 0: always
  \or
    % 1: never
  \or
    s% 2: multiple
  \or
    % 3: multiple g-last
    \ifnum\count0=\count6\ifnum\count9=0 s\fi\fi
  \or
    % 4: multiple l-last
    \ifnum\count9=1 %
    \else
      s%
    \fi
  \or
    % 5: multiple lng-last
    \ifnum\count9=1 %
    \else
      \ifnum\count0>0 %
        s%
      \fi
    \fi
  \or
    % or 6: multiple ng-last
    \ifnum\count0>0 %
      s%
    \fi
  \fi
  \noexpand\@nil
\fi
}
\newcommand*{\@@ninetiesfrench}[1]{%
\fc@case quatre\@nil-\noexpand\fc@case vingt%
\ifnum\fc@frenchoptions@vingt@plural=0 % vingt plural=always
  s%
\fi
\noexpand\@nil
-\@teenstring{#1}%
}
\newcommand*{\@@seventiesfrenchswiss}[1]{%
\@tenstring{7}%
\ifnum#1=1\ \@andname\ \fi
\ifnum#1>1-\fi
\ifnum#1>0 \@unitstring{#1}\fi
}
\newcommand*{\@@eightiesfrenchswiss}[1]{%
\@tenstring{8}%
\ifnum#1=1\ \@andname\ \fi
\ifnum#1>1-\fi
\ifnum#1>0 \@unitstring{#1}\fi
}
\newcommand*{\@@ninetiesfrenchswiss}[1]{%
\@tenstring{9}%
\ifnum#1=1\ \@andname\ \fi
\ifnum#1>1-\fi
\ifnum#1>0 \@unitstring{#1}\fi
}
%    \end{macrocode}
% \DescribeMacro\fc@french@common Macro \cs{fc@french@common} does all the preliminary settings common to all
% French dialects \& formatting options.
%    \begin{macrocode}
\newcommand*\fc@french@common{%
  \let\@unitstring=\@@unitstringfrench
  \let\@teenstring=\@@teenstringfrench
  \let\@tenstring=\@@tenstringfrench
  \def\@hundred{cent}%
  \def\@andname{et}%
}
%    \end{macrocode}
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMfrenchswiss}[2]{%
\let\fc@case\fc@CaseIden
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\let\fc@nbrstr@preamble\@empty
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@numberstringMfrenchfrance}[2]{%
\let\fc@case\fc@CaseIden
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\@empty
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@numberstringMfrenchbelgian}[2]{%
\let\fc@case\fc@CaseIden
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\@empty
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\let\@numberstringMfrench=\@numberstringMfrenchfrance
\DeclareRobustCommand{\@numberstringFfrenchswiss}[2]{%
\let\fc@case\fc@CaseIden
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\let\fc@nbrstr@preamble\fc@@nbrstr@Fpreamble
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@numberstringFfrenchfrance}[2]{%
\let\fc@case\fc@CaseIden
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\fc@@nbrstr@Fpreamble
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@numberstringFfrenchbelgian}[2]{%
\let\fc@case\fc@CaseIden
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\fc@@nbrstr@Fpreamble
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\let\@numberstringFfrench=\@numberstringFfrenchfrance
\let\@ordinalstringNfrench\@ordinalstringMfrench
\DeclareRobustCommand{\@NumberstringMfrenchswiss}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\let\fc@nbrstr@preamble\@empty
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@NumberstringMfrenchfrance}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\@empty
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@NumberstringMfrenchbelgian}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\@empty
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\let\@NumberstringMfrench=\@NumberstringMfrenchfrance
\DeclareRobustCommand{\@NumberstringFfrenchswiss}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\let\fc@nbrstr@preamble\fc@@nbrstr@Fpreamble
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@NumberstringFfrenchfrance}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\fc@@nbrstr@Fpreamble
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@NumberstringFfrenchbelgian}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\fc@@nbrstr@Fpreamble
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\let\@NumberstringFfrench=\@NumberstringFfrenchfrance
\let\@NumberstringNfrench\@NumberstringMfrench
\DeclareRobustCommand{\@ordinalstringMfrenchswiss}[2]{%
\let\fc@case\fc@CaseIden
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\@@ordinalstringfrench{#1}{#2}%
}
\newcommand*\fc@@firstfrench{premier}
\newcommand*\fc@@firstFfrench{premi\`ere}
\DeclareRobustCommand{\@ordinalstringMfrenchfrance}[2]{%
\let\fc@case\fc@CaseIden
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}}
\DeclareRobustCommand{\@ordinalstringMfrenchbelgian}[2]{%
\let\fc@case\fc@CaseIden
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\let\@ordinalstringMfrench=\@ordinalstringMfrenchfrance
\DeclareRobustCommand{\@ordinalstringFfrenchswiss}[2]{%
\let\fc@case\fc@CaseIden
\let\fc@first=\fc@@firstFfrench
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\@@ordinalstringfrench{#1}{#2}%
}
\DeclareRobustCommand{\@ordinalstringFfrenchfrance}[2]{%
\let\fc@case\fc@CaseIden
\let\fc@first=\fc@@firstFfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\DeclareRobustCommand{\@ordinalstringFfrenchbelgian}[2]{%
\let\fc@case\fc@CaseIden
\let\fc@first=\fc@@firstFfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\let\@ordinalstringFfrench=\@ordinalstringFfrenchfrance
\let\@ordinalstringNfrench\@ordinalstringMfrench
\DeclareRobustCommand{\@OrdinalstringMfrenchswiss}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\@@ordinalstringfrench{#1}{#2}%
}
\DeclareRobustCommand{\@OrdinalstringMfrenchfrance}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\DeclareRobustCommand{\@OrdinalstringMfrenchbelgian}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\let\@OrdinalstringMfrench=\@OrdinalstringMfrenchfrance
\DeclareRobustCommand{\@OrdinalstringFfrenchswiss}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\@@ordinalstringfrench{#1}{#2}%
}
\DeclareRobustCommand{\@OrdinalstringFfrenchfrance}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\let\fc@first=\fc@@firstFfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\DeclareRobustCommand{\@OrdinalstringFfrenchbelgian}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\let\fc@first=\fc@@firstFfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\let\@OrdinalstringFfrench=\@OrdinalstringFfrenchfrance
\let\@OrdinalstringNfrench\@OrdinalstringMfrench
%    \end{macrocode}
% \DescribeMacro\fc@@do@plural@mark Macro \cs{fc@@do@plural@mark} will expand to the plural mark of
% \meta{$n$}illiard, \meta{$n$}illion, mil, cent or vingt, whichever is applicable. First check that the macro
% is not yet defined.
%    \begin{macrocode}
\@ifundefined{fc@@do@plural@mark}{}{\PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@@do@plural@mark'}}
%    \end{macrocode}
% Arguments as follows:\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#1&plural mark, `s' in general, but for mil it is \cs{fc@frenchoptions@mil@plural@mark1}\\
% \end{tabularx}
% Implicit arguments as follows:\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \cs{count0}&input, counter giving the weight \(w\), this is expected to be multiple of 3,\\
%   \cs{count1}&input, counter giving the plural value of multiplied object \meta{$n$}illiard,
%   \meta{$n$}illion, mil, cent or vingt, whichever is applicable, that is to say it is 1 when the considered
%   objet is not multiplied, and 2 or more when it is multiplied,\\
%   \cs{count6}&input, counter giving the least weight of non zero digits in top level formatted number
%   integral part, with rounding down to a multiple of 3,\\
%   \cs{count10}&input, counter giving the plural mark control option.\\
% \end{tabularx}
%    \begin{macrocode}
\def\fc@@do@plural@mark#1{%
  \ifcase\count10 %
    #1% 0=always
   \or% 1=never
   \or% 2=multiple
     \ifnum\count1>1 %
       #1%
     \fi
  \or% 3= multiple g-last
     \ifnum\count1>1 %
       \ifnum\count0=\count6 %
         #1%
       \fi
     \fi
  \or% 4= multiple l-last
     \ifnum\count1>1 %
       \ifnum\count9=1 %
       \else
         #1%
       \fi
     \fi
  \or% 5= multiple lng-last
     \ifnum\count1>1 %
       \ifnum\count9=1 %
       \else
         \if\count0>\count6 %
           #1%
         \fi
       \fi
     \fi
  \or% 6= multiple ng-last
     \ifnum\count1>1 %
       \ifnum\count0>\count6 %
         #1%
       \fi
     \fi
  \fi
}
%    \end{macrocode}
% \DescribeMacro\fc@@nbrstr@Fpreamble Macro \cs{fc@@nbrstr@Fpreamble} do the necessary preliminaries before
% formatting a cardinal with feminine gender.
%    \begin{macrocode}
\@ifundefined{fc@@nbrstr@Fpreamble}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@@nbrstr@Fpreamble'}}
%    \end{macrocode}
% \DescribeMacro\fc@@nbrstr@Fpreamble
%    \begin{macrocode}
\def\fc@@nbrstr@Fpreamble{%
  \fc@read@unit{\count1}{0}%
  \ifnum\count1=1 %
      \let\fc@case@save\fc@case
      \def\fc@case{\noexpand\fc@case}%
      \def\@nil{\noexpand\@nil}%
     \let\fc@nbrstr@postamble\fc@@nbrstr@Fpostamble
  \fi
}
%    \end{macrocode}
% \DescribeMacro\fc@@nbrstr@Fpostamble
%    \begin{macrocode}
\def\fc@@nbrstr@Fpostamble{%
  \let\fc@case\fc@case@save
  \expandafter\fc@get@last@word\expandafter{\@tempa}\@tempb\@tempc
  \def\@tempd{un}%
  \ifx\@tempc\@tempd
    \let\@tempc\@tempa
    \edef\@tempa{\@tempb\fc@case une\@nil}%
  \fi
}
%    \end{macrocode}
% \DescribeMacro\fc@@pot@longscalefrench Macro \cs{fc@@pot@longscalefrench} is used to produce
% powers of ten with long scale convention. The long scale convention is correct for French and elsewhere in
% Europe. First we check that the macro is not yet defined.
%    \begin{macrocode}
\@ifundefined{fc@@pot@longscalefrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@@pot@longscalefrench'}}
%    \end{macrocode}
% Argument are as follows:\def\interface{\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#1&input, plural value of \(d\), that is to say: let \(d\) be the number multiplying the considered power
%   of ten, then the plural value \texttt{\#2} is expected to be \(0\) if \(d=0\), \(1\) if \(d=1\), or \(>1\)
%   if \(d>1\)\\
%   \#2&output, counter, maybe \(0\) when power of ten is \(1\), \(1\) when power of ten starts with
%   ``mil(le)'', or \(2\) when power of ten is a ``\meta{$n$}illion(s)\textbar\meta{$n$}illiard(s)''\\
%   \#3&output, macro into which to place the formatted power of ten
% \end{tabularx}
% Implicit arguments as follows:\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \cs{count0}&input, counter giving the weight \(w\), this is expected to be multiple of 3\\
% \end{tabularx}
% }\interface
%    \begin{macrocode}
\def\fc@@pot@longscalefrench#1#2#3{%
  {%
%    \end{macrocode}
% First the input arguments are saved into local objects: \texttt{\#1} and \texttt{\#1} are respectively saved
% into \cs{@tempa} and \cs{@tempb}.
%    \begin{macrocode}
    \edef\@tempb{\number#1}%
%    \end{macrocode}
% Let \cs{count1} be the plural value.
%    \begin{macrocode}
    \count1=\@tempb
%    \end{macrocode}
% Let \(n\) and \(r\) the the quotient and remainder of division of weight \(w\) by \(6\), that is to say \(w
% = n\times 6 + r\) and \(0\leq r < 6\), then \cs{count2} is set to \(n\) and \cs{count3} is set to \(r\).
%    \begin{macrocode}
    \count2\count0 %
    \divide\count2 by 6 %
    \count3\count2 %
    \multiply\count3 by 6 %
    \count3-\count3 %
    \advance\count3 by \count0 %
    \ifnum\count0>0 %
%    \end{macrocode}
% If weight \(w\) (a.k.a. \cs{count0}) is such that \(w>0\), then \(w\geq 3\) because \(w\) is a multiple of
% \(3\). So we \emph{may} have to append ``mil(le)'' or ``\meta{$n$}illion(s)'' or ``\meta{$n$}illiard(s)''.
%    \begin{macrocode}
      \ifnum\count1>0 %
%    \end{macrocode}
% Plural value is \(>0\) so have at least one ``mil(le)'' or ``\meta{$n$}illion(s)'' or
% ``\meta{$n$}illiard(s)''. We need to distinguish between the case of ``mil(le)'' and that of
% ``\meta{$n$}illion(s)'' or ``\meta{$n$}illiard(s)'', so we \cs{def}ine \cs{@temph} to `\texttt{1}' for
% ``mil(le)'', and to `\texttt{2}' otherwise.
%    \begin{macrocode}
        \edef\@temph{%
          \ifnum\count2=0 % weight=3
%    \end{macrocode}
% Here \(n=0\), with \(n=w\div 6\),but we also know that \(w\geq 3\), so we have \(w=3\) which means we are in
% the ``mil(le)'' case.
%    \begin{macrocode}
            1%
          \else
            \ifnum\count3>2 %
%    \end{macrocode}
% Here we are in the case of \(3\leq r < 6\), with \(r\) the remainder of division of weight \(w\) by \(6\),
% we should have ``\meta{$n$}illiard(s)'', but that may also be ``mil(le)'' instead depending on
% option `\texttt{n-illiard upto}', known as \cs{fc@longscale@nilliard@upto}.
%    \begin{macrocode}
              \ifnum\fc@longscale@nilliard@upto=0 %
%    \end{macrocode}
% Here option `\texttt{n-illiard upto}' is `\texttt{infinity}', so we always use ``\meta{$n$}illiard(s)''.
%    \begin{macrocode}
                2%
              \else
%    \end{macrocode}
% Here option `\texttt{n-illiard upto}' indicate some threshold to which to compare \(n\)
% (a.k.a. \cs{count2}).
%    \begin{macrocode}
                \ifnum\count2>\fc@longscale@nilliard@upto
                  1%
                \else
                  2%
                \fi
              \fi
            \else
              2%
            \fi
          \fi
        }%
        \ifnum\@temph=1 %
%    \end{macrocode}
% Here \(10^w\) is formatted as ``mil(le)''.
%    \begin{macrocode}
          \count10=\fc@frenchoptions@mil@plural\space
          \edef\@tempe{%
            \noexpand\fc@case
             mil%
             \fc@@do@plural@mark\fc@frenchoptions@mil@plural@mark
            \noexpand\@nil
          }%
        \else
          % weight >= 6
          \expandafter\fc@@latin@cardinal@pefix\expandafter{\the\count2}\@tempg
          % now form the xxx-illion(s) or xxx-illiard(s) word
          \ifnum\count3>2 %
             \toks10{illiard}%
             \count10=\csname fc@frenchoptions@n-illiard@plural\endcsname\space
          \else
             \toks10{illion}%
             \count10=\csname fc@frenchoptions@n-illion@plural\endcsname\space
          \fi
          \edef\@tempe{%
            \noexpand\fc@case
            \@tempg
            \the\toks10 %
            \fc@@do@plural@mark s%
            \noexpand\@nil
          }%
        \fi
      \else
%    \end{macrocode}
% Here plural indicator of \(d\) indicates that \(d = 0\), so we have \(0\times10^{w}\), and it is not worth
% to format \(10^{w}\), because there are none of them.
%    \begin{macrocode}
         \let\@tempe\@empty
         \def\@temph{0}%
      \fi
    \else
%    \end{macrocode}
% Case of \(w=0\).
%    \begin{macrocode}
      \let\@tempe\@empty
      \def\@temph{0}%
    \fi
%    \end{macrocode}
% Now place into \@cs{@tempa} the assignment of results \cs{@temph} and \cs{@tempe} to \texttt{\#2} and
% \texttt{\#3} for further propagation after closing brace.
%    \begin{macrocode}
    \expandafter\toks\expandafter1\expandafter{\@tempe}%
    \toks0{#2}%
    \edef\@tempa{\the\toks0 \@temph \def\noexpand#3{\the\toks1}}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro\fc@@pot@shortscalefrench Macro \cs{fc@@pot@shortscalefrench} is used to produce
% powers of ten with short scale convention. This convention is the US convention and is not correct for
% French and elsewhere in Europe. First we check that the macro is not yet defined.
%    \begin{macrocode}
\@ifundefined{fc@@pot@shortscalefrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@@pot@shortscalefrench'}}
%    \end{macrocode}
% Arguments as follows --- same interface as for \cs{fc@@pot@longscalefrench}:\interface
%    \begin{macrocode}
\def\fc@@pot@shortscalefrench#1#2#3{%
  {%
%    \end{macrocode}
% First save input arguments \texttt{\#1}, \texttt{\#2}, and \texttt{\#3} into local macros
% respectively \cs{@tempa}, \cs{@tempb}, \cs{@tempc} and \cs{@tempd}.
%    \begin{macrocode}
    \edef\@tempb{\number#1}%
%    \end{macrocode}
% And let \cs{count1} be the plural value.
%    \begin{macrocode}
    \count1=\@tempb
%    \end{macrocode}
% Now, let \cs{count2} be the integer \(n\) generating the pseudo latin prefix, i.e. \(n\) is such that \(w =
% 3\times n + 3\).
%    \begin{macrocode}
    \count2\count0 %
    \divide\count2 by 3 %
    \advance\count2 by -1 %
%    \end{macrocode}
% Here is the real job, the formatted power of ten will go to \cs{@tempe}, and its power type will go to
% \cs{@temph}. Please remember that the power type is an index in \([0\intv 2]\) indicating whether \(10^w\)
% is formatted as \meta{nothing}, ``mil(le)'' or ``\meta{$n$}illion(s)\textbar\meta{$n$}illiard(s)''.
%    \begin{macrocode}
    \ifnum\count0>0 % If weight>=3, i.e we do have to append thousand or n-illion(s)/n-illiard(s)
      \ifnum\count1>0 % we have at least one thousand/n-illion/n-illiard
         \ifnum\count2=0 %
           \def\@temph{1}%
           \count1=\fc@frenchoptions@mil@plural\space
           \edef\@tempe{%
             mil%
             \fc@@do@plural@mark\fc@frenchoptions@mil@plural@mark
           }%
         \else
           \def\@temph{2}%
           % weight >= 6
           \expandafter\fc@@latin@cardinal@pefix\expandafter{\the\count2}\@tempg
           \count10=\csname fc@frenchoptions@n-illion@plural\endcsname\space
           \edef\@tempe{%
             \noexpand\fc@case
             \@tempg
             illion%
             \fc@@do@plural@mark s%
             \noexpand\@nil
           }%
         \fi
      \else
%    \end{macrocode}
% Here we have \(d=0\), so nothing is to be formatted for \(d\times 10^w\).
%    \begin{macrocode}
        \def\@temph{0}%
        \let\@tempe\@empty
      \fi
    \else
%    \end{macrocode}
% Here \(w=0\).
%    \begin{macrocode}
      \def\@temph{0}%
      \let\@tempe\@empty
    \fi
% now place into \@cs{@tempa} the assignment of results \cs{@temph} and \cs{@tempe} to to \texttt{\#2} and
% \texttt{\#3} for further propagation after closing brace.
%    \begin{macrocode}
    \expandafter\toks\expandafter1\expandafter{\@tempe}%
    \toks0{#2}%
    \edef\@tempa{\the\toks0 \@temph \def\noexpand#3{\the\toks1}}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro\fc@@pot@recursivefrench Macro \cs{fc@@pot@recursivefrench} is used to produce
% power of tens that are of the form ``million de milliards de milliards'' for \(10^{24}\). First we check
% that the macro is not yet defined.
%    \begin{macrocode}
\@ifundefined{fc@@pot@recursivefrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@@pot@recursivefrench'}}
%    \end{macrocode}
% The arguments are as follows --- same interface as for \cs{fc@@pot@longscalefrench}:\interface
%    \begin{macrocode}
\def\fc@@pot@recursivefrench#1#2#3{%
  {%
%    \end{macrocode}
% First the input arguments are saved into local objects: \texttt{\#1} and \texttt{\#1} are respectively saved
% into \cs{@tempa} and \cs{@tempb}.
%    \begin{macrocode}
    \edef\@tempb{\number#1}%
    \let\@tempa\@@tempa
%    \end{macrocode}
% New get the inputs \texttt{\#1} and \texttt{\#1} into counters \cs{count0} and \cs{count1} as this is more
% practical.
%    \begin{macrocode}
    \count1=\@tempb\space
%    \end{macrocode}
% Now compute into \cs{count2} how many times ``de milliards'' has to be repeated.
%    \begin{macrocode}
    \ifnum\count1>0 %
      \count2\count0 %
      \divide\count2 by 9 %
      \advance\count2 by -1 %
      \let\@tempe\@empty
      \edef\@tempf{\fc@frenchoptions@supermillion@dos
        de\fc@frenchoptions@supermillion@dos\fc@case milliards\@nil}%
      \count11\count0 %
      \ifnum\count2>0 %
        \count3\count2 %
        \count3-\count3 %
        \multiply\count3 by 9 %
        \advance\count11 by \count3 %
        \loop
           % (\count2, \count3) <- (\count2 div 2, \count2 mod 2)
           \count3\count2 %
           \divide\count3 by 2 %
           \multiply\count3 by 2 %
           \count3-\count3 %
           \advance\count3 by \count2 %
           \divide\count2 by 2 %
           \ifnum\count3=1 %
             \let\@tempg\@tempe
             \edef\@tempe{\@tempg\@tempf}%
           \fi
           \let\@tempg\@tempf
           \edef\@tempf{\@tempg\@tempg}%
           \ifnum\count2>0 %
        \repeat
      \fi
      \divide\count11 by 3 %
      \ifcase\count11 % 0 .. 5
        % 0 => d milliard(s) (de milliards)*
        \def\@temph{2}%
        \count10=\csname fc@frenchoptions@n-illiard@plural\endcsname\space
      \or  % 1 => d mille milliard(s) (de milliards)*
        \def\@temph{1}%
        \count10=\fc@frenchoptions@mil@plural\space
      \or % 2 => d million(s) (de milliards)*
        \def\@temph{2}%
        \count10=\csname fc@frenchoptions@n-illion@plural\endcsname\space
      \or % 3 => d milliard(s) (de milliards)*
        \def\@temph{2}%
        \count10=\csname fc@frenchoptions@n-illiard@plural\endcsname\space
      \or % 4 => d mille milliards (de milliards)*
        \def\@temph{1}%
        \count10=\fc@frenchoptions@mil@plural\space
      \else % 5 => d million(s) (de milliards)*
        \def\@temph{2}%
        \count10=\csname fc@frenchoptions@n-illion@plural\endcsname\space
      \fi
      \let\@tempg\@tempe
      \edef\@tempf{%
        \ifcase\count11 % 0 .. 5
        \or
          mil\fc@@do@plural@mark \fc@frenchoptions@mil@plural@mark
        \or
          million\fc@@do@plural@mark s%
        \or
          milliard\fc@@do@plural@mark s%
        \or
          mil\fc@@do@plural@mark\fc@frenchoptions@mil@plural@mark
          \noexpand\@nil\fc@frenchoptions@supermillion@dos
          \noexpand\fc@case milliards% 4
        \or
          million\fc@@do@plural@mark s%
          \noexpand\@nil\fc@frenchoptions@supermillion@dos
          de\fc@frenchoptions@supermillion@dos\noexpand\fc@case  milliards% 5
        \fi
      }%
      \edef\@tempe{%
        \ifx\@tempf\@empty\else
         \expandafter\fc@case\@tempf\@nil
        \fi
        \@tempg
      }%
    \else
       \def\@temph{0}%
       \let\@tempe\@empty
    \fi
%    \end{macrocode}
% now place into \@cs{@tempa} the assignment of results \cs{@temph} and \cs{@tempe} to to \texttt{\#2} and
% \texttt{\#3} for further propagation after closing brace.
%    \begin{macrocode}
    \expandafter\toks\expandafter1\expandafter{\@tempe}%
    \toks0{#2}%
    \edef\@tempa{\the\toks0 \@temph \def\noexpand#3{\the\toks1}}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro\fc@muladdfrench Macro \cs{fc@muladdfrench} is used to format the sum of a number \(a\) and
% the product of a number \(d\) by a power of ten \(10^w\). Number \(d\) is made of three consecutive digits
% \(d_{w+2}d_{w+1}d_w\) of respective weights \(w+2\), \(w+1\), and \(w\), while number \(a\) is made of all
% digits with weight \(w' > w+2\) that have already been formatted. First check that the macro is not yet
% defined.
%    \begin{macrocode}
\@ifundefined{fc@muladdfrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@muladdfrench'}}
%    \end{macrocode}
% Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#2&input, plural indicator for number \(d\)\\
%   \#3&input, formatted number \(d\)\\
%   \#5&input, formatted number \(10^w\), i.e. power of ten which is multiplied by \(d\)\\
% \end{tabularx}
% Implicit arguments from context:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \cs{@tempa}&input, formatted number \(a\)\\
%              &output, macro to which place the mul-add result\\
%   \cs{count8}&input, power type indicator for \(10^{w'}\), where \(w'\) is a weight of \(a\), this is an
%   index in \([0\intv 2]\) that reflects whether \(10^{w'}\) is formatted by ``mil(le)'' --- for index \(=1\)
%   --- or by ``\meta{$n$}illion(s)\textbar\meta{$n$}illiard(s)'' --- for index \(=2\)\\
%   \cs{count9}&input, power type indicator for \(10^w\), this is an index in \([0\intv 2]\) that reflect
%   whether the weight \(w\) of \(d\) is formatted by ``meta{nothing}'' --- for index \(=0\), ``mil(le)'' ---
%   for index
%   \(=1\) --- or by ``\meta{$n$}illion(s)\textbar \meta{$n$}illiard(s)'' --- for index \(=2\)\\
% \end{tabularx}
%    \begin{macrocode}
\def\fc@muladdfrench#1#2#3{%
  {%
%    \end{macrocode}
% First we save input arguments \texttt{\#1} -- \texttt{\#3} to local macros \cs{@tempc}, \cs{@tempd} and
% \cs{@tempf}.
%    \begin{macrocode}
    \edef\@@tempc{#1}%
    \edef\@@tempd{#2}%
    \edef\@tempf{#3}%
    \let\@tempc\@@tempc
    \let\@tempd\@@tempd
%    \end{macrocode}
% First we want to do the ``multiplication'' of \(d \Rightarrow \cs{@tempd}\) and of \(10^w \Rightarrow
% \cs{@tempf}\). So, prior to this we do some preprocessing of \(d \Rightarrow \cs{@tempd}\): we force
% \cs{@tempd} to \meta{empty} if both \(d=1\) and \(10^w\Rightarrow\) ``mil(le)'', this is because we,
% French, we do not say ``un mil'', but just ``mil''.
%    \begin{macrocode}
    \ifnum\@tempc=1 %
      \ifnum\count9=1 %
        \let\@tempd\@empty
      \fi
    \fi
%    \end{macrocode}
% Now we do the ``multiplication'' of \(d = \cs{@tempd}\) and of \(10^w = \cs{@tempf}\), and place the result
% into \cs{@tempg}.
%    \begin{macrocode}
    \edef\@tempg{%
      \@tempd
      \ifx\@tempd\@empty\else
        \ifx\@tempf\@empty\else
           \ifcase\count9 %
           \or
             \fc@frenchoptions@submillion@dos
           \or
              \fc@frenchoptions@supermillion@dos
           \fi
         \fi
       \fi
     \@tempf
   }%
%    \end{macrocode}
% Now to the ``addition'' of \(a\Rightarrow \cs{@tempa}\) and \(d\times 10^w\Rightarrow \cs{@tempg}\), and
% place the results into \cs{@temph}.
%    \begin{macrocode}
   \edef\@temph{%
     \@tempa
     \ifx\@tempa\@empty\else
       \ifx\@tempg\@empty\else
         \ifcase\count8 %
         \or
           \fc@frenchoptions@submillion@dos
         \or
           \fc@frenchoptions@supermillion@dos
         \fi
       \fi
     \fi
     \@tempg
   }%
%    \end{macrocode}
% Now propagate the result --- i.e. the expansion of \cs{@temph} --- into macro \cs{@tempa} after closing
% brace.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def\@tempa{##1}}}%
    \expandafter\@tempb\expandafter{\@temph}%
    \expandafter
  }\@tempa
}%
%    \end{macrocode}
% \DescribeMacro\fc@lthundredstringfrench Macro \cs{fc@lthundredstringfrench} is used to format a number in
% interval \([0 \intv 99]\). First we check that it is not already defined.
%    \begin{macrocode}
\@ifundefined{fc@lthundredstringfrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@lthundredstringfrench'}}
%    \end{macrocode}
% The number to format is not passed as an argument to this macro, instead each digits of it is in a
% \cs{fc@digit@\meta{w}} macro after this number has been parsed. So the only thing that
% \cs{fc@lthundredstringfrench} needs is to know \meta{w} which is passed as \cs{count0} for the less
% significant digit.\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&intput/output macro to which append the result
% \end{tabularx}
% Implicit input arguments as follows:\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \cs{count0}&weight \(w\) of least significant digit \(d_{w}\).
% \end{tabularx}
% The formatted number is appended to the content of \#1, and the result is placed into \#1.
%    \begin{macrocode}
\def\fc@lthundredstringfrench#1{%
  {%
%    \end{macrocode}
% First save arguments into local temporary macro.
%    \begin{macrocode}
    \let\@tempc#1%
%    \end{macrocode}
% Read units \(d_w\) to \cs{count1}.
%    \begin{macrocode}
    \fc@read@unit{\count1}{\count0}%
%    \end{macrocode}
% Read tens \(d_{w+1}\) to \cs{count2}.
%    \begin{macrocode}
    \count3\count0 %
    \advance\count3 1 %
    \fc@read@unit{\count2}{\count3}%
%    \end{macrocode}
% Now do the real job, set macro \cs{@tempa} to \texttt{\#1} followed by \(d_{w+1}d_w\) formatted.
%    \begin{macrocode}
    \edef\@tempa{%
      \@tempc
      \ifnum\count2>1 %
        % 20 .. 99
        \ifnum\count2>6 %
          % 70 .. 99
          \ifnum\count2<8 %
             % 70 .. 79
             \@seventies{\count1}%
          \else
            % 80..99
            \ifnum\count2<9 %
              % 80 .. 89
              \@eighties{\count1}%
            \else
              % 90 .. 99
              \@nineties{\count1}%
            \fi
          \fi
        \else
          % 20..69
          \@tenstring{\count2}%
          \ifnum\count1>0 %
             % x1 .. x0
             \ifnum\count1=1 %
               % x1
               \fc@frenchoptions@submillion@dos\@andname\fc@frenchoptions@submillion@dos
             \else
               % x2 .. x9
               -%
             \fi
             \@unitstring{\count1}%
          \fi
        \fi
      \else
        % 0 .. 19
        \ifnum\count2=0 % when tens = 0
          % 0 .. 9
          \ifnum\count1=0 % when units = 0
            % \count3=1 when #1 = 0, i.e. only for the unit of the top level number
            \ifnum\count3=1 %
              \ifnum\fc@max@weight=0 %
                \@unitstring{0}%
              \fi
            \fi
          \else
            % 1 .. 9
            \@unitstring{\count1}%
          \fi
        \else
          % 10 .. 19
          \@teenstring{\count1}%
        \fi
      \fi
    }%
%    \end{macrocode}
% Now propagate the expansion of \cs{@tempa} into \texttt{\#2} after closing brace.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def#1{##1}}}%
    \expandafter\@tempb\expandafter{\@tempa}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro\fc@ltthousandstringfrench Macro \cs{fc@ltthousandstringfrench} is used to format a number in
% interval \([0 \intv 999]\). First we check that it is not already defined.
%    \begin{macrocode}
\@ifundefined{fc@ltthousandstringfrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@ltthousandstringfrench'}}
%    \end{macrocode}
% Output is empty for 0. Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#2&output, macro, formatted number \(d = d_{w+2}d_{w+1}d_w\)
% \end{tabularx}
% Implicit input arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \cs{count0}&input weight \(10^{w}\) of number \(d_{w+2}d_{w+1}d_w\) to be formatted.\\
%   \cs{count5}&least weight of formatted number with a non null digit.\\
%   \cs{count9}&input, power type indicator of \(10^{w}\) \(0\Rightarrow\varnothing\), \(1\Rightarrow\textrm {
%   ``mil(le)''}\), \(2\Rightarrow\textrm {\meta{$n$}illion(s)\textbar\meta{$n$}illiard(s)}\)\\
% \end{tabularx}
%    \begin{macrocode}
\def\fc@ltthousandstringfrench#1{%
  {%
%    \end{macrocode}
%  Set counter \cs{count2} to digit \(d_{w+2}\), i.e. hundreds.
%    \begin{macrocode}
    \count4\count0 %
    \advance\count4 by 2 %
    \fc@read@unit{\count2 }{\count4 }%
%    \end{macrocode}
% Check that the two subsequent digits \(d_{w+1}d_w\) are non zero, place check-result into \cs{@tempa}.
%    \begin{macrocode}
    \advance\count4 by -1 %
    \count3\count4 %
    \advance\count3 by -1 %
    \fc@check@nonzeros{\count3 }{\count4 }\@tempa
%    \end{macrocode}
% Compute plural mark of `cent' into \cs{@temps}.
%    \begin{macrocode}
    \edef\@temps{%
      \ifcase\fc@frenchoptions@cent@plural\space
      % 0 => always
      s%
      \or
      % 1 => never
      \or
      % 2 => multiple
      \ifnum\count2>1s\fi
      \or
      % 3 => multiple g-last
        \ifnum\count2>1 \ifnum\@tempa=0 \ifnum\count0=\count6s\fi\fi\fi
      \or
      % 4 => multiple l-last
        \ifnum\count2>1 \ifnum\@tempa=0 \ifnum\count9=0s\else\ifnum\count9=2s\fi\fi\fi\fi
      \fi
    }%
    % compute spacing after cent(s?) into \@tempb
    \expandafter\let\expandafter\@tempb
       \ifnum\@tempa>0 \fc@frenchoptions@submillion@dos\else\@empty\fi
    % now place into \@tempa the hundreds
    \edef\@tempa{%
       \ifnum\count2=0 %
       \else
         \ifnum\count2=1 %
           \expandafter\fc@case\@hundred\@nil
         \else
           \@unitstring{\count2}\fc@frenchoptions@submillion@dos
           \noexpand\fc@case\@hundred\@temps\noexpand\@nil
         \fi
         \@tempb
       \fi
    }%
    % now append to \@tempa the ten and unit
    \fc@lthundredstringfrench\@tempa
%    \end{macrocode}
% Propagate expansion of \cs{@tempa} into macro \texttt{\#2} after closing brace.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def#1{##1}}}%
    \expandafter\@tempb\expandafter{\@tempa}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro\@@numberstringfrench Macro \cs{@@numberstringfrench} is the main engine for formatting
% cadinal numbers in French. First we check that the control sequence is not yet defined.
%    \begin{macrocode}
\@ifundefined{@@numberstringfrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro `@@numberstringfrench'}}
%    \end{macrocode}
% Arguments are as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&number to convert to string\\
% \#2&macro into which to place the result
% \end{tabularx}
%    \begin{macrocode}
\def\@@numberstringfrench#1#2{%
  {%
%    \end{macrocode}
% First parse input number to be formatted and do some error handling.
%    \begin{macrocode}
    \edef\@tempa{#1}%
    \expandafter\fc@number@parser\expandafter{\@tempa}%
    \ifnum\fc@min@weight<0 %
       \PackageError{fmtcount}{Out of range}%
          {This macro does not work with fractional numbers}%
    \fi
%    \end{macrocode}
% In the sequel, \cs{@tempa} is used to accumulate the formatted number.  Please note that \cs{space} after
% \cs{fc@sign@case} is eaten by preceding number collection. This \cs{space} is needed so that when
% \cs{fc@sign@case} expands to `\texttt{0}', then \cs{@tempa} is defined to `' (i.e. empty) rather than to
% `\cs{relax}'.
%    \begin{macrocode}
    \edef\@tempa{\ifcase\fc@sign@case\space\or\fc@case plus\@nil\or\fc@case moins\@nil\fi}%
    \fc@nbrstr@preamble
    \fc@@nbrstrfrench@inner
    \fc@nbrstr@postamble
%    \end{macrocode}
% Propagate the result --- i.e. expansion of \cs{@tempa} --- into macro \texttt{\#2} after closing brace.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def#2{##1}}}%
    \expandafter\@tempb\expandafter{\@tempa}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro\fc@@nbrstrfrench@inner Common part of \cs{@@numberstringfrench} and \cs
% {@@ordinalstringfrench}. Arguments are as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \cs{@tempa}&input/output, macro to which the result is to be aggregated, initially empty or contains the
% sign indication.\\
% \end{tabularx}
%    \begin{macrocode}
\def\fc@@nbrstrfrench@inner{%
%    \end{macrocode}
% Now loop, first we compute starting weight as
% \(3\times\left\lfloor\frac{\cs{fc@max@weight}}{3}\right\rfloor\) into \cs{count0}.
%    \begin{macrocode}
    \count0=\fc@max@weight
    \divide\count0 by 3 %
    \multiply\count0 by 3 %
%    \end{macrocode}
% Now we compute final weight into \cs{count5}, and round down too multiple of \(3\) into
% \cs{count6}. Warning: \cs{count6} is an implicit input argument to macro \cs{fc@ltthousandstringfrench}.
%    \begin{macrocode}
    \fc@intpart@find@last{\count5 }%
    \count6\count5 %
    \divide\count6 3 %
    \multiply\count6 3 %
    \count8=0 %
    \loop
%    \end{macrocode}
% First we check whether digits in weight interval \([w \intv (w+2)]\) are all zero and place check result
% into macro \cs{@tempt}.
%    \begin{macrocode}
       \count1\count0 %
       \advance\count1 by 2 %
       \fc@check@nonzeros{\count0 }{\count1 }\@tempt
%    \end{macrocode}
% Now we generate the power of ten \(10^w\), formatted power of ten goes to \cs{@tempb}, while power type
% indicator goes to \cs{count9}.
%    \begin{macrocode}
       \fc@poweroften\@tempt{\count9 }\@tempb
%    \end{macrocode}
% Now we generate the formatted number \(d\) into macro \cs{@tempd} by which we need to multiply
% \(10^w\). Implicit input argument is \cs{count9} for power type of \(10^9\), and \cs{count6}
%    \begin{macrocode}
       \fc@ltthousandstringfrench\@tempd
%    \end{macrocode}
% Finally do the multiplication-addition. Implicit arguments are \cs{@tempa} for input/output growing
% formatted number, \cs{count8} for input previous power type, i.e. power type of \(10^{w+3}\), \cs{count9}
% for input current power type, i.e. power type of \(10^w\).
%    \begin{macrocode}
       \fc@muladdfrench\@tempt\@tempd\@tempb
%    \end{macrocode}
% Then iterate.
%    \begin{macrocode}
       \count8\count9 %
       \advance\count0 by -3 %
       \ifnum\count6>\count0 \else
    \repeat
}
%    \end{macrocode}
% \DescribeMacro\@@ordinalstringfrench Macro \cs{@@ordinalstringfrench} is the main engine for formatting
% ordinal numbers in French. First check it is not yet defined.
%    \begin{macrocode}
\@ifundefined{@@ordinalstringfrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `@@ordinalstringfrench'}}
%    \end{macrocode}
% Arguments are as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&number to convert to string\\
% \#2&macro into which to place the result
% \end{tabularx}
%    \begin{macrocode}
\def\@@ordinalstringfrench#1#2{%
  {%
%    \end{macrocode}
% First parse input number to be formatted and do some error handling.
%    \begin{macrocode}
    \edef\@tempa{#1}%
    \expandafter\fc@number@parser\expandafter{\@tempa}%
    \ifnum\fc@min@weight<0 %
       \PackageError{fmtcount}{Out of range}%
          {This macro does not work with fractional numbers}%
    \fi
    \ifnum\fc@sign@case>0 %
       \PackageError{fmtcount}{Out of range}%
          {This macro does with negative or explicitly marked as positive numbers}%
    \fi
%    \end{macrocode}
% Now handle the special case of first. We set \cs{count0} to \texttt{1} if we are in this case, and to
% \texttt{0} otherwise
%    \begin{macrocode}
    \ifnum\fc@max@weight=0 %
      \ifnum\csname fc@digit@0\endcsname=1 %
        \count0=1 %
      \else
        \count0=0 % 
      \fi
    \else
      \count0=0 % 
    \fi
    \ifnum\count0=1 %
      \edef\@tempa{\expandafter\fc@case\fc@first\@nil}%
    \else
%    \end{macrocode}
% Now we tamper a little bit with the plural handling options to ensure that there is no final plural mark.
%    \begin{macrocode}
      \def\@tempa##1{%
        \expandafter\edef\csname fc@frenchoptions@##1@plural\endcsname{%
          \ifcase\csname fc@frenchoptions@##1@plural\endcsname\space
          0% 0: always => always
          \or
          1% 1: never => never
          \or
          6% 2: multiple => multiple  ng-last
          \or
          1% 3: multiple g-last => never
          \or
          5% 4: multiple l-last => multiple lng-last
          \or
          5% 5: multiple lng-last => multiple lng-last
          \or
          6% 6: multiple ng-last => multiple ng-last
          \fi
        }%
      }%
      \@tempa{vingt}%
      \@tempa{cent}%
      \@tempa{mil}%
      \@tempa{n-illion}%
      \@tempa{n-illiard}%
%    \end{macrocode}
% Now make \cs{fc@case} and \cs{@nil} non expandable
%    \begin{macrocode}
      \let\fc@case@save\fc@case
      \def\fc@case{\noexpand\fc@case}%
      \def\@nil{\noexpand\@nil}%
%    \end{macrocode}
% In the sequel, \cs{@tempa} is used to accumulate the formatted number.
%    \begin{macrocode}
      \let\@tempa\@empty
      \fc@@nbrstrfrench@inner
%    \end{macrocode}
% Now restore \cs{fc@case}
%    \begin{macrocode}
     \let\fc@case\fc@case@save
%    \end{macrocode}
% Now we add the ``i\`eme'' ending
%    \begin{macrocode}
      \expandafter\fc@get@last@word\expandafter{\@tempa}\@tempb\@tempc
      \expandafter\fc@get@last@letter\expandafter{\@tempc}\@tempd\@tempe
      \def\@tempf{e}%
      \ifx\@tempe\@tempf
        \edef\@tempa{\@tempb\expandafter\fc@case\@tempd i\`eme\@nil}%
      \else
        \def\@tempf{q}%
        \ifx\@tempe\@tempf
          \edef\@tempa{\@tempb\expandafter\fc@case\@tempd qui\`eme\@nil}%
        \else
          \def\@tempf{f}%
          \ifx\@tempe\@tempf
            \edef\@tempa{\@tempb\expandafter\fc@case\@tempd vi\`eme\@nil}%
          \else
            \edef\@tempa{\@tempb\expandafter\fc@case\@tempc i\`eme\@nil}%
          \fi
        \fi
      \fi
    \fi
%    \end{macrocode}
% Propagate the result --- i.e. expansion of \cs{@tempa} --- into macro \texttt{\#2} after closing brace.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def#2{##1}}}%
    \expandafter\@tempb\expandafter{\@tempa}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% Macro \cs{fc@frenchoptions@setdefaults} allows to set all options to default for the French.
%    \begin{macrocode}
\newcommand*\fc@frenchoptions@setdefaults{%
  \csname KV@fcfrench@all plural\endcsname{reformed}%
  \def\fc@frenchoptions@submillion@dos{-}%
  \let\fc@frenchoptions@supermillion@dos\space
  \let\fc@u@in@duo\@empty% Could be `u'
  % \let\fc@poweroften\fc@@pot@longscalefrench
  \let\fc@poweroften\fc@@pot@recursivefrench
  \def\fc@longscale@nilliard@upto{0}% infinity
  \def\fc@frenchoptions@mil@plural@mark{le}%
}
\fc@frenchoptions@setdefaults
%    \end{macrocode}
\iffalse Local variables: \fi
\iffalse mode: docTeX     \fi
\iffalse End:             \fi
%\iffalse
%    \begin{macrocode}
%</fc-french.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-frenchb.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-frenchb.def}
%    \begin{macrocode}
\ProvidesFCLanguage{frenchb}[2012/06/18]
\FCloadlang{french}
%    \end{macrocode}
% Set |frenchb| to be equivalent to |french|.
%    \begin{macrocode}
\let\@ordinalMfrenchb=\@ordinalMfrench
\let\@ordinalFfrenchb=\@ordinalFfrench
\let\@ordinalNfrenchb=\@ordinalNfrench
\let\@numberstringMfrenchb=\@numberstringMfrench
\let\@numberstringFfrenchb=\@numberstringFfrench
\let\@numberstringNfrenchb=\@numberstringNfrench
\let\@NumberstringMfrenchb=\@NumberstringMfrench
\let\@NumberstringFfrenchb=\@NumberstringFfrench
\let\@NumberstringNfrenchb=\@NumberstringNfrench
\let\@ordinalstringMfrenchb=\@ordinalstringMfrench
\let\@ordinalstringFfrenchb=\@ordinalstringFfrench
\let\@ordinalstringNfrenchb=\@ordinalstringNfrench
\let\@OrdinalstringMfrenchb=\@OrdinalstringMfrench
\let\@OrdinalstringFfrenchb=\@OrdinalstringFfrench
\let\@OrdinalstringNfrenchb=\@OrdinalstringNfrench
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-frenchb.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-german.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-german.def}
% German definitions (thank you to K. H. Fricke for supplying
% this information)
%    \begin{macrocode}
\ProvidesFCLanguage{german}[2012/06/18]
%    \end{macrocode}
% Define macro that converts a number or count register (first
% argument) to an ordinal, and stores the result in the
% second argument, which must be a control sequence.
% Masculine:
%    \begin{macrocode}
\newcommand{\@ordinalMgerman}[2]{%
\edef#2{\number#1\relax.}}
%    \end{macrocode}
% Feminine:
%    \begin{macrocode}
\newcommand{\@ordinalFgerman}[2]{%
\edef#2{\number#1\relax.}}
%    \end{macrocode}
% Neuter:
%    \begin{macrocode}
\newcommand{\@ordinalNgerman}[2]{%
\edef#2{\number#1\relax.}}
%    \end{macrocode}
% Convert a number to text. The easiest way to do this is to
% break it up into units, tens and teens.
% Units (argument must be a number from 0 to 9, 1 on its own (eins)
% is dealt with separately):
%    \begin{macrocode}
\newcommand{\@@unitstringgerman}[1]{%
\ifcase#1%
null%
\or eins%
\or zwei%
\or drei%
\or vier%
\or f\"unf%
\or sechs%
\or sieben%
\or acht%
\or neun%
\fi
}
%    \end{macrocode}
% Tens (argument must go from 1 to 10):
%    \begin{macrocode}
\newcommand{\@@tenstringgerman}[1]{%
\ifcase#1%
\or zehn%
\or zwanzig%
\or drei{\ss}ig%
\or vierzig%
\or f\"unfzig%
\or sechzig%
\or siebzig%
\or achtzig%
\or neunzig%
\or einhundert%
\fi
}
%    \end{macrocode}
% |\einhundert| is set to |einhundert| by default, user can
% redefine this command to just |hundert| if required, similarly
% for |\eintausend|.
%    \begin{macrocode}
\providecommand*{\einhundert}{einhundert}
\providecommand*{\eintausend}{eintausend}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand{\@@teenstringgerman}[1]{%
\ifcase#1%
zehn%
\or elf%
\or zw\"olf%
\or dreizehn%
\or vierzehn%
\or f\"unfzehn%
\or sechzehn%
\or siebzehn%
\or achtzehn%
\or neunzehn%
\fi
}
%    \end{macrocode}
% The results are stored in the second argument, but doesn't 
% display anything.
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMgerman}[2]{%
\let\@unitstring=\@@unitstringgerman
\let\@teenstring=\@@teenstringgerman
\let\@tenstring=\@@tenstringgerman
\@@numberstringgerman{#1}{#2}}
%    \end{macrocode}
% Feminine and neuter forms:
%    \begin{macrocode}
\let\@numberstringFgerman=\@numberstringMgerman
\let\@numberstringNgerman=\@numberstringMgerman
%    \end{macrocode}
% As above, but initial letters in upper case:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringMgerman}[2]{%
  \@numberstringMgerman{#1}{\@@num@str}%
 \edef#2{\noexpand\MakeUppercase\expandonce\@@num@str}%
}
%    \end{macrocode}
% Feminine and neuter form:
%    \begin{macrocode}
\let\@NumberstringFgerman=\@NumberstringMgerman
\let\@NumberstringNgerman=\@NumberstringMgerman
%    \end{macrocode}
% As above, but for ordinals.
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMgerman}[2]{%
\let\@unitthstring=\@@unitthstringMgerman
\let\@teenthstring=\@@teenthstringMgerman
\let\@tenthstring=\@@tenthstringMgerman
\let\@unitstring=\@@unitstringgerman
\let\@teenstring=\@@teenstringgerman
\let\@tenstring=\@@tenstringgerman
\def\@thousandth{tausendster}%
\def\@hundredth{hundertster}%
\@@ordinalstringgerman{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringFgerman}[2]{%
\let\@unitthstring=\@@unitthstringFgerman
\let\@teenthstring=\@@teenthstringFgerman
\let\@tenthstring=\@@tenthstringFgerman
\let\@unitstring=\@@unitstringgerman
\let\@teenstring=\@@teenstringgerman
\let\@tenstring=\@@tenstringgerman
\def\@thousandth{tausendste}%
\def\@hundredth{hundertste}%
\@@ordinalstringgerman{#1}{#2}}
%    \end{macrocode}
% Neuter form:
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringNgerman}[2]{%
\let\@unitthstring=\@@unitthstringNgerman
\let\@teenthstring=\@@teenthstringNgerman
\let\@tenthstring=\@@tenthstringNgerman
\let\@unitstring=\@@unitstringgerman
\let\@teenstring=\@@teenstringgerman
\let\@tenstring=\@@tenstringgerman
\def\@thousandth{tausendstes}%
\def\@hundredth{hunderstes}%
\@@ordinalstringgerman{#1}{#2}}
%    \end{macrocode}
% As above, but with initial letters in upper case.
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMgerman}[2]{%
 \@ordinalstringMgerman{#1}{\@@num@str}%
 \edef#2{\noexpand\MakeUppercase\expandonce\@@num@str}%
}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringFgerman}[2]{%
 \@ordinalstringFgerman{#1}{\@@num@str}%
 \edef#2{\noexpand\MakeUppercase\expandonce\@@num@str}%
}
%    \end{macrocode}
% Neuter form:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringNgerman}[2]{%
 \@ordinalstringNgerman{#1}{\@@num@str}%
 \edef#2{\noexpand\MakeUppercase\expandonce\@@num@str}%
}
%    \end{macrocode}
% Code for converting numbers into textual ordinals. As before,
% it is easier to split it into units, tens and teens.
% Units:
%\changes{2.0}{2012-09-25}{fixed spelling mistake (correction
%provided by Dominik Wa\ss enhoven)}
%    \begin{macrocode}
\newcommand{\@@unitthstringMgerman}[1]{%
\ifcase#1%
nullter%
\or erster%
\or zweiter%
\or dritter%
\or vierter%
\or f\"unfter%
\or sechster%
\or siebter%
\or achter%
\or neunter%
\fi
}
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand{\@@tenthstringMgerman}[1]{%
\ifcase#1%
\or zehnter%
\or zwanzigster%
\or drei{\ss}igster%
\or vierzigster%
\or f\"unfzigster%
\or sechzigster%
\or siebzigster%
\or achtzigster%
\or neunzigster%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand{\@@teenthstringMgerman}[1]{%
\ifcase#1%
zehnter%
\or elfter%
\or zw\"olfter%
\or dreizehnter%
\or vierzehnter%
\or f\"unfzehnter%
\or sechzehnter%
\or siebzehnter%
\or achtzehnter%
\or neunzehnter%
\fi
}
%    \end{macrocode}
% Units (feminine):
%    \begin{macrocode}
\newcommand{\@@unitthstringFgerman}[1]{%
\ifcase#1%
nullte%
\or erste%
\or zweite%
\or dritte%
\or vierte%
\or f\"unfte%
\or sechste%
\or siebte%
\or achte%
\or neunte%
\fi
}
%    \end{macrocode}
% Tens (feminine):
%    \begin{macrocode}
\newcommand{\@@tenthstringFgerman}[1]{%
\ifcase#1%
\or zehnte%
\or zwanzigste%
\or drei{\ss}igste%
\or vierzigste%
\or f\"unfzigste%
\or sechzigste%
\or siebzigste%
\or achtzigste%
\or neunzigste%
\fi
}
%    \end{macrocode}
% Teens (feminine)
%    \begin{macrocode}
\newcommand{\@@teenthstringFgerman}[1]{%
\ifcase#1%
zehnte%
\or elfte%
\or zw\"olfte%
\or dreizehnte%
\or vierzehnte%
\or f\"unfzehnte%
\or sechzehnte%
\or siebzehnte%
\or achtzehnte%
\or neunzehnte%
\fi
}
%    \end{macrocode}
% Units (neuter):
%\changes{2.0}{2012-09-25}{fixed spelling mistake (correction
%provided by Dominik Wa\ss enhoven)}
%    \begin{macrocode}
\newcommand{\@@unitthstringNgerman}[1]{%
\ifcase#1%
nulltes%
\or erstes%
\or zweites%
\or drittes%
\or viertes%
\or f\"unftes%
\or sechstes%
\or siebtes%
\or achtes%
\or neuntes%
\fi
}
%    \end{macrocode}
% Tens (neuter):
%    \begin{macrocode}
\newcommand{\@@tenthstringNgerman}[1]{%
\ifcase#1%
\or zehntes%
\or zwanzigstes%
\or drei{\ss}igstes%
\or vierzigstes%
\or f\"unfzigstes%
\or sechzigstes%
\or siebzigstes%
\or achtzigstes%
\or neunzigstes%
\fi
}
%    \end{macrocode}
% Teens (neuter)
%    \begin{macrocode}
\newcommand{\@@teenthstringNgerman}[1]{%
\ifcase#1%
zehntes%
\or elftes%
\or zw\"olftes%
\or dreizehntes%
\or vierzehntes%
\or f\"unfzehntes%
\or sechzehntes%
\or siebzehntes%
\or achtzehntes%
\or neunzehntes%
\fi
}
%    \end{macrocode}
% This appends the results to |\#2| for number |\#2| (in range 0 to
% 100.)
% null and eins are dealt with separately in
% |\@@numberstringgerman|.
%    \begin{macrocode}
\newcommand{\@@numberunderhundredgerman}[2]{%
\ifnum#1<10\relax
  \ifnum#1>0\relax
    \eappto#2{\@unitstring{#1}}%
  \fi
\else
  \@tmpstrctr=#1\relax
  \@modulo{\@tmpstrctr}{10}%
  \ifnum#1<20\relax
    \eappto#2{\@teenstring{\@tmpstrctr}}%
  \else
    \ifnum\@tmpstrctr=0\relax
    \else
      \eappto#2{\@unitstring{\@tmpstrctr}und}%
    \fi
    \@tmpstrctr=#1\relax
    \divide\@tmpstrctr by 10\relax
    \eappto#2{\@tenstring{\@tmpstrctr}}%
  \fi
\fi
}
%    \end{macrocode}
% This stores the results in the second argument 
% (which must be a control
% sequence), but it doesn't display anything.
%    \begin{macrocode}
\newcommand{\@@numberstringgerman}[2]{%
\ifnum#1>99999\relax
  \PackageError{fmtcount}{Out of range}%
  {This macro only works for values less than 100000}%
\else
  \ifnum#1<0\relax
    \PackageError{fmtcount}{Negative numbers not permitted}%
    {This macro does not work for negative numbers, however
    you can try typing "minus" first, and then pass the modulus of
    this number}%
  \fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>1\relax
%    \end{macrocode}
% \#1 is $\geq 2000$, \cs{@strctr} now contains the number of thousands
%    \begin{macrocode}
 \@@numberunderhundredgerman{\@strctr}{#2}%
  \appto#2{tausend}%
\else
%    \end{macrocode}
% \#1 lies in range [1000,1999]
%    \begin{macrocode}
  \ifnum\@strctr=1\relax
    \eappto#2{\eintausend}%
  \fi
\fi
\@strctr=#1\relax
\@modulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>1\relax
%    \end{macrocode}
% now dealing with number in range [200,999]
%    \begin{macrocode}
  \eappto#2{\@unitstring{\@strctr}hundert}%
\else
   \ifnum\@strctr=1\relax
%    \end{macrocode}
% dealing with number in range [100,199]
%    \begin{macrocode}
     \ifnum#1>1000\relax
%    \end{macrocode}
% if original number $> 1000$, use einhundert
%    \begin{macrocode}
        \appto#2{einhundert}%
     \else
%    \end{macrocode}
% otherwise use \cs{einhundert}
%    \begin{macrocode}
        \eappto#2{\einhundert}%
      \fi
   \fi
\fi
\@strctr=#1\relax
\@modulo{\@strctr}{100}%
\ifnum#1=0\relax
  \def#2{null}%
\else
  \ifnum\@strctr=1\relax
    \appto#2{eins}%
  \else
    \@@numberunderhundredgerman{\@strctr}{#2}%
  \fi
\fi
}
%    \end{macrocode}
% As above, but for ordinals
%    \begin{macrocode}
\newcommand{\@@numberunderhundredthgerman}[2]{%
\ifnum#1<10\relax
 \eappto#2{\@unitthstring{#1}}%
\else
  \@tmpstrctr=#1\relax
  \@modulo{\@tmpstrctr}{10}%
  \ifnum#1<20\relax
    \eappto#2{\@teenthstring{\@tmpstrctr}}%
  \else
    \ifnum\@tmpstrctr=0\relax
    \else
      \eappto#2{\@unitstring{\@tmpstrctr}und}%
    \fi
    \@tmpstrctr=#1\relax
    \divide\@tmpstrctr by 10\relax
    \eappto#2{\@tenthstring{\@tmpstrctr}}%
  \fi
\fi
}
%    \end{macrocode}
%    \begin{macrocode}
\newcommand{\@@ordinalstringgerman}[2]{%
\ifnum#1>99999\relax
  \PackageError{fmtcount}{Out of range}%
  {This macro only works for values less than 100000}%
\else
  \ifnum#1<0\relax
    \PackageError{fmtcount}{Negative numbers not permitted}%
    {This macro does not work for negative numbers, however
    you can try typing "minus" first, and then pass the modulus of
    this number}%
  \fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>1\relax
%    \end{macrocode}
% \#1 is $\geq 2000$, \cs{@strctr} now contains the number of thousands
%    \begin{macrocode}
\@@numberunderhundredgerman{\@strctr}{#2}%
%    \end{macrocode}
% is that it, or is there more?
%    \begin{macrocode}
  \@tmpstrctr=#1\relax \@modulo{\@tmpstrctr}{1000}%
  \ifnum\@tmpstrctr=0\relax
    \eappto#2{\@thousandth}%
  \else
    \appto#2{tausend}%
  \fi
\else
%    \end{macrocode}
% \#1 lies in range [1000,1999]
%    \begin{macrocode}
  \ifnum\@strctr=1\relax
    \ifnum#1=1000\relax
      \eappto#2{\@thousandth}%
    \else
      \eappto#2{\eintausend}%
    \fi
  \fi
\fi
\@strctr=#1\relax
\@modulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>1\relax
%    \end{macrocode}
% now dealing with number in range [200,999]
% is that it, or is there more?
%    \begin{macrocode}
  \@tmpstrctr=#1\relax \@modulo{\@tmpstrctr}{100}%
  \ifnum\@tmpstrctr=0\relax
     \ifnum\@strctr=1\relax
       \eappto#2{\@hundredth}%
     \else
       \eappto#2{\@unitstring{\@strctr}\@hundredth}%
     \fi
  \else
     \eappto#2{\@unitstring{\@strctr}hundert}%
  \fi
\else
   \ifnum\@strctr=1\relax
%    \end{macrocode}
% dealing with number in range [100,199]
% is that it, or is there more?
%    \begin{macrocode}
     \@tmpstrctr=#1\relax \@modulo{\@tmpstrctr}{100}%
     \ifnum\@tmpstrctr=0\relax
        \eappto#2{\@hundredth}%
     \else
     \ifnum#1>1000\relax
        \appto#2{einhundert}%
     \else
        \eappto#2{\einhundert}%
     \fi
     \fi
   \fi
\fi
\@strctr=#1\relax
\@modulo{\@strctr}{100}%
\ifthenelse{\@strctr=0 \and #1>0}{}{%
\@@numberunderhundredthgerman{\@strctr}{#2}%
}%
}
%    \end{macrocode}
% Load fc-germanb.def if not already loaded
%    \begin{macrocode}
\FCloadlang{germanb}
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-german.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-germanb.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-germanb.def}
%    \begin{macrocode}
\ProvidesFCLanguage{germanb}[2012/06/18]
%    \end{macrocode}
% Load fc-german.def if not already loaded
%    \begin{macrocode}
\FCloadlang{german}
%    \end{macrocode}
% Set |germanb| to be equivalent to |german|.
%    \begin{macrocode}
\let\@ordinalMgermanb=\@ordinalMgerman
\let\@ordinalFgermanb=\@ordinalFgerman
\let\@ordinalNgermanb=\@ordinalNgerman
\let\@numberstringMgermanb=\@numberstringMgerman
\let\@numberstringFgermanb=\@numberstringFgerman
\let\@numberstringNgermanb=\@numberstringNgerman
\let\@NumberstringMgermanb=\@NumberstringMgerman
\let\@NumberstringFgermanb=\@NumberstringFgerman
\let\@NumberstringNgermanb=\@NumberstringNgerman
\let\@ordinalstringMgermanb=\@ordinalstringMgerman
\let\@ordinalstringFgermanb=\@ordinalstringFgerman
\let\@ordinalstringNgermanb=\@ordinalstringNgerman
\let\@OrdinalstringMgermanb=\@OrdinalstringMgerman
\let\@OrdinalstringFgermanb=\@OrdinalstringFgerman
\let\@OrdinalstringNgermanb=\@OrdinalstringNgerman
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-germanb.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-italian.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-italian}
% Italian support is now handled by interfacing to Enrico Gregorio's
% itnumpar package.
%    \begin{macrocode}
\ProvidesFCLanguage{italian}[2012/06/18]

\RequirePackage{itnumpar}

\newcommand{\@numberstringMitalian}[2]{%
  \edef#2{\noexpand\printnumeroinparole{#1}}%
}

\newcommand{\@numberstringFitalian}[2]{%
  \edef#2{\noexpand\printnumeroinparole{#1}}}

\newcommand{\@NumberstringMitalian}[2]{%
  \edef#2{\noexpand\printNumeroinparole{#1}}}

\newcommand{\@NumberstringFitalian}[2]{%
  \edef#2{\noexpand\printNumeroinparole{#1}}}

\newcommand{\@ordinalstringMitalian}[2]{%
  \edef#2{\noexpand\printordinalem{#1}}}

\newcommand{\@ordinalstringFitalian}[2]{%
  \edef#2{\noexpand\printordinalef{#1}}}

\newcommand{\@OrdinalstringMitalian}[2]{%
  \edef#2{\noexpand\printOrdinalem{#1}}}

\newcommand{\@OrdinalstringFitalian}[2]{%
  \edef#2{\noexpand\printOrdinalef{#1}}}

\newcommand{\@ordinalMitalian}[2]{%
  \edef#2{#1\relax\noexpand\fmtord{o}}}
\newcommand{\@ordinalFitalian}[2]{%
  \edef#2{#1\relax\noexpand\fmtord{a}}}
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-italian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-ngerman.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-ngerman.def}
%    \begin{macrocode}
\ProvidesFCLanguage{ngerman}[2012/06/18]
\FCloadlang{german}
\FCloadlang{ngermanb}
%    \end{macrocode}
% Set |ngerman| to be equivalent to |german|. Is it okay to do
% this? (I don't know the difference between the two.)
%    \begin{macrocode}
\let\@ordinalMngerman=\@ordinalMgerman
\let\@ordinalFngerman=\@ordinalFgerman
\let\@ordinalNngerman=\@ordinalNgerman
\let\@numberstringMngerman=\@numberstringMgerman
\let\@numberstringFngerman=\@numberstringFgerman
\let\@numberstringNngerman=\@numberstringNgerman
\let\@NumberstringMngerman=\@NumberstringMgerman
\let\@NumberstringFngerman=\@NumberstringFgerman
\let\@NumberstringNngerman=\@NumberstringNgerman
\let\@ordinalstringMngerman=\@ordinalstringMgerman
\let\@ordinalstringFngerman=\@ordinalstringFgerman
\let\@ordinalstringNngerman=\@ordinalstringNgerman
\let\@OrdinalstringMngerman=\@OrdinalstringMgerman
\let\@OrdinalstringFngerman=\@OrdinalstringFgerman
\let\@OrdinalstringNngerman=\@OrdinalstringNgerman
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-ngerman.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-ngermanb.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-ngermanb.def}
%    \begin{macrocode}
\ProvidesFCLanguage{ngermanb}[2012/06/18]
\FCloadlang{german}
%    \end{macrocode}
% Set |ngermanb| to be equivalent to |german|. Is it okay to do
% this? (I don't know the difference between the two.)
%    \begin{macrocode}
\let\@ordinalMngermanb=\@ordinalMgerman
\let\@ordinalFngermanb=\@ordinalFgerman
\let\@ordinalNngermanb=\@ordinalNgerman
\let\@numberstringMngermanb=\@numberstringMgerman
\let\@numberstringFngermanb=\@numberstringFgerman
\let\@numberstringNngermanb=\@numberstringNgerman
\let\@NumberstringMngermanb=\@NumberstringMgerman
\let\@NumberstringFngermanb=\@NumberstringFgerman
\let\@NumberstringNngermanb=\@NumberstringNgerman
\let\@ordinalstringMngermanb=\@ordinalstringMgerman
\let\@ordinalstringFngermanb=\@ordinalstringFgerman
\let\@ordinalstringNngermanb=\@ordinalstringNgerman
\let\@OrdinalstringMngermanb=\@OrdinalstringMgerman
\let\@OrdinalstringFngermanb=\@OrdinalstringFgerman
\let\@OrdinalstringNngermanb=\@OrdinalstringNgerman
%    \end{macrocode}
% Load fc-ngerman.def if not already loaded
%    \begin{macrocode}
\FCloadlang{ngerman}
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-ngermanb.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-portuges.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-portuges.def}
% Portuguse definitions
%    \begin{macrocode}
\ProvidesFCLanguage{portuges}[2012/06/18]
%    \end{macrocode}
% Define macro that converts a number or count register (first
% argument) to an ordinal, and stores the result in the second
% argument, which should be a control sequence. Masculine:
%    \begin{macrocode}
\newcommand*{\@ordinalMportuges}[2]{%
\ifnum#1=0\relax
  \edef#2{\number#1}%
\else
  \edef#2{\number#1\relax\noexpand\fmtord{o}}%
\fi}
%    \end{macrocode}
% Feminine:
%    \begin{macrocode}
\newcommand*{\@ordinalFportuges}[2]{%
\ifnum#1=0\relax
  \edef#2{\number#1}%
\else
  \edef#2{\number#1\relax\noexpand\fmtord{a}}%
\fi}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@ordinalNportuges\@ordinalMportuges
%    \end{macrocode}
% Convert a number to a textual representation. To make it easier,
% split it up into units, tens, teens and hundreds. Units (argument
% must
% be a number from 0 to 9):
%    \begin{macrocode}
\newcommand*{\@@unitstringportuges}[1]{%
\ifcase#1\relax
zero%
\or um%
\or dois%
\or tr\^es%
\or quatro%
\or cinco%
\or seis%
\or sete%
\or oito%
\or nove%
\fi
}
%   \end{macrocode}
% As above, but for feminine:
%   \begin{macrocode}
\newcommand*{\@@unitstringFportuges}[1]{%
\ifcase#1\relax
zero%
\or uma%
\or duas%
\or tr\^es%
\or quatro%
\or cinco%
\or seis%
\or sete%
\or oito%
\or nove%
\fi
}
%    \end{macrocode}
% Tens (argument must be a number from 0 to 10):
%    \begin{macrocode}
\newcommand*{\@@tenstringportuges}[1]{%
\ifcase#1\relax
\or dez%
\or vinte%
\or trinta%
\or quarenta%
\or cinq\"uenta%
\or sessenta%
\or setenta%
\or oitenta%
\or noventa%
\or cem%
\fi
}
%    \end{macrocode}
% Teens (argument must be a number from 0 to 9):
%    \begin{macrocode}
\newcommand*{\@@teenstringportuges}[1]{%
\ifcase#1\relax
dez%
\or onze%
\or doze%
\or treze%
\or quatorze%
\or quinze%
\or dezesseis%
\or dezessete%
\or dezoito%
\or dezenove%
\fi
}
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand*{\@@hundredstringportuges}[1]{%
\ifcase#1\relax
\or cento%
\or duzentos%
\or trezentos%
\or quatrocentos%
\or quinhentos%
\or seiscentos%
\or setecentos%
\or oitocentos%
\or novecentos%
\fi}
%    \end{macrocode}
% Hundreds (feminine):
%    \begin{macrocode}
\newcommand*{\@@hundredstringFportuges}[1]{%
\ifcase#1\relax
\or cento%
\or duzentas%
\or trezentas%
\or quatrocentas%
\or quinhentas%
\or seiscentas%
\or setecentas%
\or oitocentas%
\or novecentas%
\fi}
%    \end{macrocode}
% Units (initial letter in upper case):
%    \begin{macrocode}
\newcommand*{\@@Unitstringportuges}[1]{%
\ifcase#1\relax
Zero%
\or Um%
\or Dois%
\or Tr\^es%
\or Quatro%
\or Cinco%
\or Seis%
\or Sete%
\or Oito%
\or Nove%
\fi
}
%    \end{macrocode}
% As above, but feminine:
%    \begin{macrocode}
\newcommand*{\@@UnitstringFportuges}[1]{%
\ifcase#1\relax
Zera%
\or Uma%
\or Duas%
\or Tr\^es%
\or Quatro%
\or Cinco%
\or Seis%
\or Sete%
\or Oito%
\or Nove%
\fi
}
%    \end{macrocode}
% Tens (with initial letter in upper case):
%    \begin{macrocode}
\newcommand*{\@@Tenstringportuges}[1]{%
\ifcase#1\relax
\or Dez%
\or Vinte%
\or Trinta%
\or Quarenta%
\or Cinq\"uenta%
\or Sessenta%
\or Setenta%
\or Oitenta%
\or Noventa%
\or Cem%
\fi
}
%    \end{macrocode}
% Teens (with initial letter in upper case):
%    \begin{macrocode}
\newcommand*{\@@Teenstringportuges}[1]{%
\ifcase#1\relax
Dez%
\or Onze%
\or Doze%
\or Treze%
\or Quatorze%
\or Quinze%
\or Dezesseis%
\or Dezessete%
\or Dezoito%
\or Dezenove%
\fi
}
%    \end{macrocode}
% Hundreds (with initial letter in upper case):
%    \begin{macrocode}
\newcommand*{\@@Hundredstringportuges}[1]{%
\ifcase#1\relax
\or Cento%
\or Duzentos%
\or Trezentos%
\or Quatrocentos%
\or Quinhentos%
\or Seiscentos%
\or Setecentos%
\or Oitocentos%
\or Novecentos%
\fi}
%    \end{macrocode}
% As above, but feminine:
%    \begin{macrocode}
\newcommand*{\@@HundredstringFportuges}[1]{%
\ifcase#1\relax
\or Cento%
\or Duzentas%
\or Trezentas%
\or Quatrocentas%
\or Quinhentas%
\or Seiscentas%
\or Setecentas%
\or Oitocentas%
\or Novecentas%
\fi}
%    \end{macrocode}
% This has changed in version 1.08, so that it now stores
% the result in the second argument, but doesn't display
% anything. Since it only affects internal macros, it shouldn't
% affect documents created with older versions. (These internal
% macros are not meant for use in documents.)
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMportuges}[2]{%
\let\@unitstring=\@@unitstringportuges
\let\@teenstring=\@@teenstringportuges
\let\@tenstring=\@@tenstringportuges
\let\@hundredstring=\@@hundredstringportuges
\def\@hundred{cem}\def\@thousand{mil}%
\def\@andname{e}%
\@@numberstringportuges{#1}{#2}}
%    \end{macrocode}
% As above, but feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringFportuges}[2]{%
\let\@unitstring=\@@unitstringFportuges
\let\@teenstring=\@@teenstringportuges
\let\@tenstring=\@@tenstringportuges
\let\@hundredstring=\@@hundredstringFportuges
\def\@hundred{cem}\def\@thousand{mil}%
\def\@andname{e}%
\@@numberstringportuges{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@numberstringNportuges\@numberstringMportuges
%    \end{macrocode}
% As above, but initial letters in upper case:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringMportuges}[2]{%
\let\@unitstring=\@@Unitstringportuges
\let\@teenstring=\@@Teenstringportuges
\let\@tenstring=\@@Tenstringportuges
\let\@hundredstring=\@@Hundredstringportuges
\def\@hundred{Cem}\def\@thousand{Mil}%
\def\@andname{e}%
\@@numberstringportuges{#1}{#2}}
%    \end{macrocode}
% As above, but feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringFportuges}[2]{%
\let\@unitstring=\@@UnitstringFportuges
\let\@teenstring=\@@Teenstringportuges
\let\@tenstring=\@@Tenstringportuges
\let\@hundredstring=\@@HundredstringFportuges
\def\@hundred{Cem}\def\@thousand{Mil}%
\def\@andname{e}%
\@@numberstringportuges{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@NumberstringNportuges\@NumberstringMportuges
%    \end{macrocode}
% As above, but for ordinals.
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMportuges}[2]{%
\let\@unitthstring=\@@unitthstringportuges
\let\@unitstring=\@@unitstringportuges
\let\@teenthstring=\@@teenthstringportuges
\let\@tenthstring=\@@tenthstringportuges
\let\@hundredthstring=\@@hundredthstringportuges
\def\@thousandth{mil\'esimo}%
\@@ordinalstringportuges{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringFportuges}[2]{%
\let\@unitthstring=\@@unitthstringFportuges
\let\@unitstring=\@@unitstringFportuges
\let\@teenthstring=\@@teenthstringportuges
\let\@tenthstring=\@@tenthstringFportuges
\let\@hundredthstring=\@@hundredthstringFportuges
\def\@thousandth{mil\'esima}%
\@@ordinalstringportuges{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@ordinalstringNportuges\@ordinalstringMportuges
%    \end{macrocode}
% As above, but initial letters in upper case (masculine):
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMportuges}[2]{%
\let\@unitthstring=\@@Unitthstringportuges
\let\@unitstring=\@@Unitstringportuges
\let\@teenthstring=\@@teenthstringportuges
\let\@tenthstring=\@@Tenthstringportuges
\let\@hundredthstring=\@@Hundredthstringportuges
\def\@thousandth{Mil\'esimo}%
\@@ordinalstringportuges{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringFportuges}[2]{%
\let\@unitthstring=\@@UnitthstringFportuges
\let\@unitstring=\@@UnitstringFportuges
\let\@teenthstring=\@@teenthstringportuges
\let\@tenthstring=\@@TenthstringFportuges
\let\@hundredthstring=\@@HundredthstringFportuges
\def\@thousandth{Mil\'esima}%
\@@ordinalstringportuges{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@OrdinalstringNportuges\@OrdinalstringMportuges
%    \end{macrocode}
% In order to do the ordinals, split into units, teens, tens
% and hundreds. Units:
%    \begin{macrocode}
\newcommand*{\@@unitthstringportuges}[1]{%
\ifcase#1\relax
zero%
\or primeiro%
\or segundo%
\or terceiro%
\or quarto%
\or quinto%
\or sexto%
\or s\'etimo%
\or oitavo%
\or nono%
\fi
}
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand*{\@@tenthstringportuges}[1]{%
\ifcase#1\relax
\or d\'ecimo%
\or vig\'esimo%
\or trig\'esimo%
\or quadrag\'esimo%
\or q\"uinquag\'esimo%
\or sexag\'esimo%
\or setuag\'esimo%
\or octog\'esimo%
\or nonag\'esimo%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand*{\@@teenthstringportuges}[1]{%
\@tenthstring{1}%
\ifnum#1>0\relax
-\@unitthstring{#1}%
\fi}
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand*{\@@hundredthstringportuges}[1]{%
\ifcase#1\relax
\or cent\'esimo%
\or ducent\'esimo%
\or trecent\'esimo%
\or quadringent\'esimo%
\or q\"uingent\'esimo%
\or seiscent\'esimo%
\or setingent\'esimo%
\or octingent\'esimo%
\or nongent\'esimo%
\fi}
%    \end{macrocode}
% Units (feminine):
%    \begin{macrocode}
\newcommand*{\@@unitthstringFportuges}[1]{%
\ifcase#1\relax
zero%
\or primeira%
\or segunda%
\or terceira%
\or quarta%
\or quinta%
\or sexta%
\or s\'etima%
\or oitava%
\or nona%
\fi
}
%    \end{macrocode}
% Tens (feminine):
%    \begin{macrocode}
\newcommand*{\@@tenthstringFportuges}[1]{%
\ifcase#1\relax
\or d\'ecima%
\or vig\'esima%
\or trig\'esima%
\or quadrag\'esima%
\or q\"uinquag\'esima%
\or sexag\'esima%
\or setuag\'esima%
\or octog\'esima%
\or nonag\'esima%
\fi
}
%    \end{macrocode}
% Hundreds (feminine):
%    \begin{macrocode}
\newcommand*{\@@hundredthstringFportuges}[1]{%
\ifcase#1\relax
\or cent\'esima%
\or ducent\'esima%
\or trecent\'esima%
\or quadringent\'esima%
\or q\"uingent\'esima%
\or seiscent\'esima%
\or setingent\'esima%
\or octingent\'esima%
\or nongent\'esima%
\fi}
%    \end{macrocode}
% As above, but with initial letter in upper case. Units:
%    \begin{macrocode}
\newcommand*{\@@Unitthstringportuges}[1]{%
\ifcase#1\relax
Zero%
\or Primeiro%
\or Segundo%
\or Terceiro%
\or Quarto%
\or Quinto%
\or Sexto%
\or S\'etimo%
\or Oitavo%
\or Nono%
\fi
}
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand*{\@@Tenthstringportuges}[1]{%
\ifcase#1\relax
\or D\'ecimo%
\or Vig\'esimo%
\or Trig\'esimo%
\or Quadrag\'esimo%
\or Q\"uinquag\'esimo%
\or Sexag\'esimo%
\or Setuag\'esimo%
\or Octog\'esimo%
\or Nonag\'esimo%
\fi
}
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand*{\@@Hundredthstringportuges}[1]{%
\ifcase#1\relax
\or Cent\'esimo%
\or Ducent\'esimo%
\or Trecent\'esimo%
\or Quadringent\'esimo%
\or Q\"uingent\'esimo%
\or Seiscent\'esimo%
\or Setingent\'esimo%
\or Octingent\'esimo%
\or Nongent\'esimo%
\fi}
%    \end{macrocode}
% As above, but feminine. Units:
%    \begin{macrocode}
\newcommand*{\@@UnitthstringFportuges}[1]{%
\ifcase#1\relax
Zera%
\or Primeira%
\or Segunda%
\or Terceira%
\or Quarta%
\or Quinta%
\or Sexta%
\or S\'etima%
\or Oitava%
\or Nona%
\fi
}
%    \end{macrocode}
% Tens (feminine);
%    \begin{macrocode}
\newcommand*{\@@TenthstringFportuges}[1]{%
\ifcase#1\relax
\or D\'ecima%
\or Vig\'esima%
\or Trig\'esima%
\or Quadrag\'esima%
\or Q\"uinquag\'esima%
\or Sexag\'esima%
\or Setuag\'esima%
\or Octog\'esima%
\or Nonag\'esima%
\fi
}
%    \end{macrocode}
% Hundreds (feminine):
%    \begin{macrocode}
\newcommand*{\@@HundredthstringFportuges}[1]{%
\ifcase#1\relax
\or Cent\'esima%
\or Ducent\'esima%
\or Trecent\'esima%
\or Quadringent\'esima%
\or Q\"uingent\'esima%
\or Seiscent\'esima%
\or Setingent\'esima%
\or Octingent\'esima%
\or Nongent\'esima%
\fi}
%    \end{macrocode}
% This has changed in version 1.09, so that it now stores
% the result in the second argument (a control sequence), but it
% doesn't display anything. Since it only affects internal macros,
% it shouldn't affect documents created with older versions.
% (These internal macros are not meant for use in documents.)
%    \begin{macrocode}
\newcommand*{\@@numberstringportuges}[2]{%
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9
%    \end{macrocode}
% \#1 is greater or equal to 10000
%    \begin{macrocode}
  \divide\@strctr by 10
  \ifnum\@strctr>1\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
    \@strctr=#1 \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \ifnum\@strctr>0
      \ifnum\@strctr=1\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\ \@andname}%
      \fi
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\ \@unitstring{\@strctr}}%
    \fi
  \else
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\ \@thousand}%
\else
  \ifnum\@strctr>0\relax
    \ifnum\@strctr>1\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ }%
    \fi
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@thousand}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>0\relax
  \ifnum#1>1000 \relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ }%
  \fi
  \@tmpstrctr=#1\relax
  \@modulo{\@tmpstrctr}{1000}%
  \let\@@fc@numstr#2\relax
  \ifnum\@tmpstrctr=100\relax
    \edef#2{\@@fc@numstr\@tenstring{10}}%
  \else
    \edef#2{\@@fc@numstr\@hundredstring{\@strctr}}%
  \fi%
\fi
\@strctr=#1\relax \@modulo{\@strctr}{100}%
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ \@andname\ }%
  \fi
\fi
\ifnum\@strctr>19\relax
  \divide\@strctr by 10\relax
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
  \@strctr=#1\relax \@modulo{\@strctr}{10}%
  \ifnum\@strctr>0
    \ifnum\@strctr=1\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\ \@andname}%
    \else
      \ifnum#1>100\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\ \@andname}%
      \fi
    \fi
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ \@unitstring{\@strctr}}%
  \fi
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
      \ifnum#1<100\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
      \fi
    \else%(>0,<10)
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
    \fi
  \else%>10
    \@modulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
\fi
}
%    \end{macrocode}
% As above, but for ordinals.
%    \begin{macrocode}
\newcommand*{\@@ordinalstringportuges}[2]{%
\@strctr=#1\relax
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\else
\def#2{}%
\ifnum\@strctr>999\relax
  \divide\@strctr by 1000\relax
  \ifnum\@strctr>1\relax
    \ifnum\@strctr>9\relax
      \@tmpstrctr=\@strctr
      \ifnum\@strctr<20
        \@modulo{\@tmpstrctr}{10}%
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@teenthstring{\@tmpstrctr}}%
      \else
        \divide\@tmpstrctr by 10\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@tenthstring{\@tmpstrctr}}%
        \@tmpstrctr=\@strctr
        \@modulo{\@tmpstrctr}{10}%
        \ifnum\@tmpstrctr>0\relax
          \let\@@fc@ordstr#2\relax
          \edef#2{\@@fc@ordstr\@unitthstring{\@tmpstrctr}}%
        \fi
      \fi
    \else
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
    \fi
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@thousandth}%
\fi
\@strctr=#1\relax
\@modulo{\@strctr}{1000}%
\ifnum\@strctr>99\relax
  \@tmpstrctr=\@strctr
  \divide\@tmpstrctr by 100\relax
  \ifnum#1>1000\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr-}%
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@hundredthstring{\@tmpstrctr}}%
\fi
\@modulo{\@strctr}{100}%
\ifnum#1>99\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr-}%
  \fi
\fi
\ifnum\@strctr>9\relax
  \@tmpstrctr=\@strctr
  \divide\@tmpstrctr by 10\relax
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@tenthstring{\@tmpstrctr}}%
  \@tmpstrctr=\@strctr
  \@modulo{\@tmpstrctr}{10}%
  \ifnum\@tmpstrctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr-\@unitthstring{\@tmpstrctr}}%
  \fi
\else
  \ifnum\@strctr=0\relax
    \ifnum#1=0\relax
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@unitstring{0}}%
    \fi
  \else
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
  \fi
\fi
\fi
\fi
}
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-portuges.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-spanish.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-spanish.def}
% Spanish definitions
%    \begin{macrocode}
\ProvidesFCLanguage{spanish}[2012/06/18]
%    \end{macrocode}
% Define macro that converts a number or count register (first
% argument) to an ordinal, and stores the result in the
% second argument, which must be a control sequence.
% Masculine:
%    \begin{macrocode}
\newcommand{\@ordinalMspanish}[2]{%
\edef#2{\number#1\relax\noexpand\fmtord{o}}}
%    \end{macrocode}
% Feminine:
%    \begin{macrocode}
\newcommand{\@ordinalFspanish}[2]{%
\edef#2{\number#1\relax\noexpand\fmtord{a}}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@ordinalNspanish\@ordinalMspanish
%    \end{macrocode}
% Convert a number to text. The easiest way to do this is to
% break it up into units, tens, teens, twenties and hundreds.
% Units (argument must be a number from 0 to 9):
%    \begin{macrocode}
\newcommand{\@@unitstringspanish}[1]{%
\ifcase#1\relax
cero%
\or uno%
\or dos%
\or tres%
\or cuatro%
\or cinco%
\or seis%
\or siete%
\or ocho%
\or nueve%
\fi
}
%    \end{macrocode}
% Feminine:
%    \begin{macrocode}
\newcommand{\@@unitstringFspanish}[1]{%
\ifcase#1\relax
cera%
\or una%
\or dos%
\or tres%
\or cuatro%
\or cinco%
\or seis%
\or siete%
\or ocho%
\or nueve%
\fi
}
%    \end{macrocode}
% Tens (argument must go from 1 to 10):
%\changes{2.0}{2012-06-18}{fixed spelling mistake (correction
%provided by Fernando Maldonado)}
%    \begin{macrocode}
\newcommand{\@@tenstringspanish}[1]{%
\ifcase#1\relax
\or diez%
\or veinte%
\or treinta%
\or cuarenta%
\or cincuenta%
\or sesenta%
\or setenta%
\or ochenta%
\or noventa%
\or cien%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand{\@@teenstringspanish}[1]{%
\ifcase#1\relax
diez%
\or once%
\or doce%
\or trece%
\or catorce%
\or quince%
\or diecis\'eis%
\or diecisiete%
\or dieciocho%
\or diecinueve%
\fi
}
%    \end{macrocode}
% Twenties:
%    \begin{macrocode}
\newcommand{\@@twentystringspanish}[1]{%
\ifcase#1\relax
veinte%
\or veintiuno%
\or veintid\'os%
\or veintitr\'es%
\or veinticuatro%
\or veinticinco%
\or veintis\'eis%
\or veintisiete%
\or veintiocho%
\or veintinueve%
\fi}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand{\@@twentystringFspanish}[1]{%
\ifcase#1\relax
veinte%
\or veintiuna%
\or veintid\'os%
\or veintitr\'es%
\or veinticuatro%
\or veinticinco%
\or veintis\'eis%
\or veintisiete%
\or veintiocho%
\or veintinueve%
\fi}
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand{\@@hundredstringspanish}[1]{%
\ifcase#1\relax
\or ciento%
\or doscientos%
\or trescientos%
\or cuatrocientos%
\or quinientos%
\or seiscientos%
\or setecientos%
\or ochocientos%
\or novecientos%
\fi}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand{\@@hundredstringFspanish}[1]{%
\ifcase#1\relax
\or cienta%
\or doscientas%
\or trescientas%
\or cuatrocientas%
\or quinientas%
\or seiscientas%
\or setecientas%
\or ochocientas%
\or novecientas%
\fi}
%    \end{macrocode}
% As above, but with initial letter uppercase:
%    \begin{macrocode}
\newcommand{\@@Unitstringspanish}[1]{%
\ifcase#1\relax
Cero%
\or Uno%
\or Dos%
\or Tres%
\or Cuatro%
\or Cinco%
\or Seis%
\or Siete%
\or Ocho%
\or Nueve%
\fi
}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand{\@@UnitstringFspanish}[1]{%
\ifcase#1\relax
Cera%
\or Una%
\or Dos%
\or Tres%
\or Cuatro%
\or Cinco%
\or Seis%
\or Siete%
\or Ocho%
\or Nueve%
\fi
}
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
%\changes{2.0}{2012-06-18}{fixed spelling mistake (correction
%provided by Fernando Maldonado)}
\newcommand{\@@Tenstringspanish}[1]{%
\ifcase#1\relax
\or Diez%
\or Veinte%
\or Treinta%
\or Cuarenta%
\or Cincuenta%
\or Sesenta%
\or Setenta%
\or Ochenta%
\or Noventa%
\or Cien%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand{\@@Teenstringspanish}[1]{%
\ifcase#1\relax
Diez%
\or Once%
\or Doce%
\or Trece%
\or Catorce%
\or Quince%
\or Diecis\'eis%
\or Diecisiete%
\or Dieciocho%
\or Diecinueve%
\fi
}
%    \end{macrocode}
% Twenties:
%    \begin{macrocode}
\newcommand{\@@Twentystringspanish}[1]{%
\ifcase#1\relax
Veinte%
\or Veintiuno%
\or Veintid\'os%
\or Veintitr\'es%
\or Veinticuatro%
\or Veinticinco%
\or Veintis\'eis%
\or Veintisiete%
\or Veintiocho%
\or Veintinueve%
\fi}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand{\@@TwentystringFspanish}[1]{%
\ifcase#1\relax
Veinte%
\or Veintiuna%
\or Veintid\'os%
\or Veintitr\'es%
\or Veinticuatro%
\or Veinticinco%
\or Veintis\'eis%
\or Veintisiete%
\or Veintiocho%
\or Veintinueve%
\fi}
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand{\@@Hundredstringspanish}[1]{%
\ifcase#1\relax
\or Ciento%
\or Doscientos%
\or Trescientos%
\or Cuatrocientos%
\or Quinientos%
\or Seiscientos%
\or Setecientos%
\or Ochocientos%
\or Novecientos%
\fi}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand{\@@HundredstringFspanish}[1]{%
\ifcase#1\relax
\or Cienta%
\or Doscientas%
\or Trescientas%
\or Cuatrocientas%
\or Quinientas%
\or Seiscientas%
\or Setecientas%
\or Ochocientas%
\or Novecientas%
\fi}
%    \end{macrocode}
% This has changed in version 1.09, so that it now stores the
% result in the second argument, but doesn't display anything.
% Since it only affects internal macros, it shouldn't affect
% documents created with older versions. (These internal macros
% are not meant for use in documents.)
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMspanish}[2]{%
\let\@unitstring=\@@unitstringspanish
\let\@teenstring=\@@teenstringspanish
\let\@tenstring=\@@tenstringspanish
\let\@twentystring=\@@twentystringspanish
\let\@hundredstring=\@@hundredstringspanish
\def\@hundred{cien}\def\@thousand{mil}%
\def\@andname{y}%
\@@numberstringspanish{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%\changes{2.0}{2012-06-18}{changed andname to `b' (correction
%provided by Fernando Maldonado)}
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringFspanish}[2]{%
\let\@unitstring=\@@unitstringFspanish
\let\@teenstring=\@@teenstringspanish
\let\@tenstring=\@@tenstringspanish
\let\@twentystring=\@@twentystringFspanish
\let\@hundredstring=\@@hundredstringFspanish
\def\@hundred{cien}\def\@thousand{mil}%
\def\@andname{b}%
\@@numberstringspanish{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@numberstringNspanish\@numberstringMspanish
%    \end{macrocode}
% As above, but initial letters in upper case:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringMspanish}[2]{%
\let\@unitstring=\@@Unitstringspanish
\let\@teenstring=\@@Teenstringspanish
\let\@tenstring=\@@Tenstringspanish
\let\@twentystring=\@@Twentystringspanish
\let\@hundredstring=\@@Hundredstringspanish
\def\@andname{y}%
\def\@hundred{Cien}\def\@thousand{Mil}%
\@@numberstringspanish{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%\changes{2.0}{2012-06-18}{changed andname to `b' (correction
%provided by Fernando Maldonado)}
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringFspanish}[2]{%
\let\@unitstring=\@@UnitstringFspanish
\let\@teenstring=\@@Teenstringspanish
\let\@tenstring=\@@Tenstringspanish
\let\@twentystring=\@@TwentystringFspanish
\let\@hundredstring=\@@HundredstringFspanish
\def\@andname{b}%
\def\@hundred{Cien}\def\@thousand{Mil}%
\@@numberstringspanish{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@NumberstringNspanish\@NumberstringMspanish
%    \end{macrocode}
% As above, but for ordinals.
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMspanish}[2]{%
\let\@unitthstring=\@@unitthstringspanish
\let\@unitstring=\@@unitstringspanish
\let\@teenthstring=\@@teenthstringspanish
\let\@tenthstring=\@@tenthstringspanish
\let\@hundredthstring=\@@hundredthstringspanish
\def\@thousandth{mil\'esimo}%
\@@ordinalstringspanish{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringFspanish}[2]{%
\let\@unitthstring=\@@unitthstringFspanish
\let\@unitstring=\@@unitstringFspanish
\let\@teenthstring=\@@teenthstringFspanish
\let\@tenthstring=\@@tenthstringFspanish
\let\@hundredthstring=\@@hundredthstringFspanish
\def\@thousandth{mil\'esima}%
\@@ordinalstringspanish{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@ordinalstringNspanish\@ordinalstringMspanish
%    \end{macrocode}
% As above, but with initial letters in upper case.
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMspanish}[2]{%
\let\@unitthstring=\@@Unitthstringspanish
\let\@unitstring=\@@Unitstringspanish
\let\@teenthstring=\@@Teenthstringspanish
\let\@tenthstring=\@@Tenthstringspanish
\let\@hundredthstring=\@@Hundredthstringspanish
\def\@thousandth{Mil\'esimo}%
\@@ordinalstringspanish{#1}{#2}}
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringFspanish}[2]{%
\let\@unitthstring=\@@UnitthstringFspanish
\let\@unitstring=\@@UnitstringFspanish
\let\@teenthstring=\@@TeenthstringFspanish
\let\@tenthstring=\@@TenthstringFspanish
\let\@hundredthstring=\@@HundredthstringFspanish
\def\@thousandth{Mil\'esima}%
\@@ordinalstringspanish{#1}{#2}}
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\let\@OrdinalstringNspanish\@OrdinalstringMspanish
%    \end{macrocode}
% Code for convert numbers into textual ordinals. As before,
% it is easier to split it into units, tens, teens and hundreds.
% Units:
%    \begin{macrocode}
\newcommand{\@@unitthstringspanish}[1]{%
\ifcase#1\relax
cero%
\or primero%
\or segundo%
\or tercero%
\or cuarto%
\or quinto%
\or sexto%
\or s\'eptimo%
\or octavo%
\or noveno%
\fi
}
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand{\@@tenthstringspanish}[1]{%
\ifcase#1\relax
\or d\'ecimo%
\or vig\'esimo%
\or trig\'esimo%
\or cuadrag\'esimo%
\or quincuag\'esimo%
\or sexag\'esimo%
\or septuag\'esimo%
\or octog\'esimo%
\or nonag\'esimo%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand{\@@teenthstringspanish}[1]{%
\ifcase#1\relax
d\'ecimo%
\or und\'ecimo%
\or duod\'ecimo%
\or decimotercero%
\or decimocuarto%
\or decimoquinto%
\or decimosexto%
\or decimos\'eptimo%
\or decimoctavo%
\or decimonoveno%
\fi
}
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand{\@@hundredthstringspanish}[1]{%
\ifcase#1\relax
\or cent\'esimo%
\or ducent\'esimo%
\or tricent\'esimo%
\or cuadringent\'esimo%
\or quingent\'esimo%
\or sexcent\'esimo%
\or septing\'esimo%
\or octingent\'esimo%
\or noningent\'esimo%
\fi}
%    \end{macrocode}
% Units (feminine):
%    \begin{macrocode}
\newcommand{\@@unitthstringFspanish}[1]{%
\ifcase#1\relax
cera%
\or primera%
\or segunda%
\or tercera%
\or cuarta%
\or quinta%
\or sexta%
\or s\'eptima%
\or octava%
\or novena%
\fi
}
%    \end{macrocode}
% Tens (feminine):
%    \begin{macrocode}
\newcommand{\@@tenthstringFspanish}[1]{%
\ifcase#1\relax
\or d\'ecima%
\or vig\'esima%
\or trig\'esima%
\or cuadrag\'esima%
\or quincuag\'esima%
\or sexag\'esima%
\or septuag\'esima%
\or octog\'esima%
\or nonag\'esima%
\fi
}
%    \end{macrocode}
% Teens (feminine)
%    \begin{macrocode}
\newcommand{\@@teenthstringFspanish}[1]{%
\ifcase#1\relax
d\'ecima%
\or und\'ecima%
\or duod\'ecima%
\or decimotercera%
\or decimocuarta%
\or decimoquinta%
\or decimosexta%
\or decimos\'eptima%
\or decimoctava%
\or decimonovena%
\fi
}
%    \end{macrocode}
% Hundreds (feminine)
%    \begin{macrocode}
\newcommand{\@@hundredthstringFspanish}[1]{%
\ifcase#1\relax
\or cent\'esima%
\or ducent\'esima%
\or tricent\'esima%
\or cuadringent\'esima%
\or quingent\'esima%
\or sexcent\'esima%
\or septing\'esima%
\or octingent\'esima%
\or noningent\'esima%
\fi}
%    \end{macrocode}
% As above, but with initial letters in upper case
%    \begin{macrocode}
\newcommand{\@@Unitthstringspanish}[1]{%
\ifcase#1\relax
Cero%
\or Primero%
\or Segundo%
\or Tercero%
\or Cuarto%
\or Quinto%
\or Sexto%
\or S\'eptimo%
\or Octavo%
\or Noveno%
\fi
}
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand{\@@Tenthstringspanish}[1]{%
\ifcase#1\relax
\or D\'ecimo%
\or Vig\'esimo%
\or Trig\'esimo%
\or Cuadrag\'esimo%
\or Quincuag\'esimo%
\or Sexag\'esimo%
\or Septuag\'esimo%
\or Octog\'esimo%
\or Nonag\'esimo%
\fi
}
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand{\@@Teenthstringspanish}[1]{%
\ifcase#1\relax
D\'ecimo%
\or Und\'ecimo%
\or Duod\'ecimo%
\or Decimotercero%
\or Decimocuarto%
\or Decimoquinto%
\or Decimosexto%
\or Decimos\'eptimo%
\or Decimoctavo%
\or Decimonoveno%
\fi
}
%    \end{macrocode}
% Hundreds
%    \begin{macrocode}
\newcommand{\@@Hundredthstringspanish}[1]{%
\ifcase#1\relax
\or Cent\'esimo%
\or Ducent\'esimo%
\or Tricent\'esimo%
\or Cuadringent\'esimo%
\or Quingent\'esimo%
\or Sexcent\'esimo%
\or Septing\'esimo%
\or Octingent\'esimo%
\or Noningent\'esimo%
\fi}
%    \end{macrocode}
% As above, but feminine.
%    \begin{macrocode}
\newcommand{\@@UnitthstringFspanish}[1]{%
\ifcase#1\relax
Cera%
\or Primera%
\or Segunda%
\or Tercera%
\or Cuarta%
\or Quinta%
\or Sexta%
\or S\'eptima%
\or Octava%
\or Novena%
\fi
}
%    \end{macrocode}
% Tens (feminine)
%    \begin{macrocode}
\newcommand{\@@TenthstringFspanish}[1]{%
\ifcase#1\relax
\or D\'ecima%
\or Vig\'esima%
\or Trig\'esima%
\or Cuadrag\'esima%
\or Quincuag\'esima%
\or Sexag\'esima%
\or Septuag\'esima%
\or Octog\'esima%
\or Nonag\'esima%
\fi
}
%    \end{macrocode}
% Teens (feminine):
%    \begin{macrocode}
\newcommand{\@@TeenthstringFspanish}[1]{%
\ifcase#1\relax
D\'ecima%
\or Und\'ecima%
\or Duod\'ecima%
\or Decimotercera%
\or Decimocuarta%
\or Decimoquinta%
\or Decimosexta%
\or Decimos\'eptima%
\or Decimoctava%
\or Decimonovena%
\fi
}
%    \end{macrocode}
% Hundreds (feminine):
%    \begin{macrocode}
\newcommand{\@@HundredthstringFspanish}[1]{%
\ifcase#1\relax
\or Cent\'esima%
\or Ducent\'esima%
\or Tricent\'esima%
\or Cuadringent\'esima%
\or Quingent\'esima%
\or Sexcent\'esima%
\or Septing\'esima%
\or Octingent\'esima%
\or Noningent\'esima%
\fi}
%    \end{macrocode}
% This has changed in version 1.09, so that it now stores the
% results in the second argument (which must be a control
% sequence), but it doesn't display anything. Since it only
% affects internal macros, it shouldn't affect documnets created
% with older versions. (These internal macros are not meant for
% use in documents.)
%    \begin{macrocode}
\newcommand{\@@numberstringspanish}[2]{%
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9
%    \end{macrocode}
% \#1 is greater or equal to 10000
%    \begin{macrocode}
  \divide\@strctr by 10
  \ifnum\@strctr>1
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
    \@strctr=#1 \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \ifnum\@strctr>0\relax
       \let\@@fc@numstr#2\relax
       \edef#2{\@@fc@numstr\ \@andname\ \@unitstring{\@strctr}}%
    \fi
  \else
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@modulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\ \@thousand}%
\else
  \ifnum\@strctr>0\relax
    \ifnum\@strctr>1\relax
       \let\@@fc@numstr#2\relax
       \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ }%
    \fi
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@thousand}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>0\relax
  \ifnum#1>1000\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ }%
  \fi
  \@tmpstrctr=#1\relax
  \@modulo{\@tmpstrctr}{1000}%
  \ifnum\@tmpstrctr=100\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{10}}%
  \else
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@hundredstring{\@strctr}}%
  \fi
\fi
\@strctr=#1\relax \@modulo{\@strctr}{100}%
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
%    \end{macrocode}
%\changes{2.0}{2012-06-18}{removed andname (correction
%provided by Fernando Maldonado)}
%    \begin{macrocode}
    \edef#2{\@@fc@numstr\ }%
  \fi
\fi
\ifnum\@strctr>29\relax
  \divide\@strctr by 10\relax
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
  \@strctr=#1\relax \@modulo{\@strctr}{10}%
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ \@andname\ \@unitstring{\@strctr}}%
  \fi
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
      \ifnum#1<100\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
      \fi
    \else
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
    \fi
  \else
    \ifnum\@strctr>19\relax
      \@modulo{\@strctr}{10}%
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@twentystring{\@strctr}}%
    \else
      \@modulo{\@strctr}{10}%
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
    \fi
  \fi
\fi
}
%    \end{macrocode}
% As above, but for ordinals
%    \begin{macrocode}
\newcommand{\@@ordinalstringspanish}[2]{%
\@strctr=#1\relax
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\else
\def#2{}%
\ifnum\@strctr>999\relax
  \divide\@strctr by 1000\relax
  \ifnum\@strctr>1\relax
    \ifnum\@strctr>9\relax
      \@tmpstrctr=\@strctr
      \ifnum\@strctr<20
        \@modulo{\@tmpstrctr}{10}%
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@teenthstring{\@tmpstrctr}}%
      \else
        \divide\@tmpstrctr by 10\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@tenthstring{\@tmpstrctr}}%
        \@tmpstrctr=\@strctr
        \@modulo{\@tmpstrctr}{10}%
        \ifnum\@tmpstrctr>0\relax
          \let\@@fc@ordstr#2\relax
          \edef#2{\@@fc@ordstr\@unitthstring{\@tmpstrctr}}%
        \fi
      \fi
    \else
       \let\@@fc@ordstr#2\relax
       \edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
    \fi
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@thousandth}%
\fi
\@strctr=#1\relax
\@modulo{\@strctr}{1000}%
\ifnum\@strctr>99\relax
  \@tmpstrctr=\@strctr
  \divide\@tmpstrctr by 100\relax
  \ifnum#1>1000\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ }%
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@hundredthstring{\@tmpstrctr}}%
\fi
\@modulo{\@strctr}{100}%
\ifnum#1>99\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ }%
  \fi
\fi
\ifnum\@strctr>19\relax
  \@tmpstrctr=\@strctr
  \divide\@tmpstrctr by 10\relax
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@tenthstring{\@tmpstrctr}}%
  \@tmpstrctr=\@strctr
  \@modulo{\@tmpstrctr}{10}%
  \ifnum\@tmpstrctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@unitthstring{\@tmpstrctr}}%
  \fi
\else
  \ifnum\@strctr>9\relax
    \@modulo{\@strctr}{10}%
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@teenthstring{\@strctr}}%
  \else
    \ifnum\@strctr=0\relax
      \ifnum#1=0\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@unitstring{0}}%
      \fi
    \else
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
    \fi
  \fi
\fi
\fi
\fi
}
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-spanish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-UKenglish.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-UKenglish.def}
% English definitions
%    \begin{macrocode}
\ProvidesFCLanguage{UKenglish}[2012/06/18]
%    \end{macrocode}
% Loaded fc-english.def if not already loaded
%    \begin{macrocode}
\FCloadlang{english}
%    \end{macrocode}
% These are all just synonyms for the commands provided by
% fc-english.def.
%    \begin{macrocode}
\let\@ordinalMUKenglish\@ordinalMenglish
\let\@ordinalFUKenglish\@ordinalMenglish
\let\@ordinalNUKenglish\@ordinalMenglish
\let\@numberstringMUKenglish\@numberstringMenglish
\let\@numberstringFUKenglish\@numberstringMenglish
\let\@numberstringNUKenglish\@numberstringMenglish
\let\@NumberstringMUKenglish\@NumberstringMenglish
\let\@NumberstringFUKenglish\@NumberstringMenglish
\let\@NumberstringNUKenglish\@NumberstringMenglish
\let\@ordinalstringMUKenglish\@ordinalstringMenglish
\let\@ordinalstringFUKenglish\@ordinalstringMenglish
\let\@ordinalstringNUKenglish\@ordinalstringMenglish
\let\@OrdinalstringMUKenglish\@OrdinalstringMenglish
\let\@OrdinalstringFUKenglish\@OrdinalstringMenglish
\let\@OrdinalstringNUKenglish\@OrdinalstringMenglish
%    \end{macrocode} 
%\iffalse
%    \begin{macrocode}
%</fc-UKenglish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-USenglish.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-USenglish.def}
% US English definitions
%    \begin{macrocode}
\ProvidesFCLanguage{USenglish}[2012/06/18]
%    \end{macrocode}
% Loaded fc-english.def if not already loaded
%    \begin{macrocode}
\FCloadlang{english}
%    \end{macrocode}
% These are all just synonyms for the commands provided by
% fc-english.def. (This needs fixing as there are some differences
% between UK and US number strings.)
%    \begin{macrocode}
\let\@ordinalMUSenglish\@ordinalMenglish
\let\@ordinalFUSenglish\@ordinalMenglish
\let\@ordinalNUSenglish\@ordinalMenglish
\let\@numberstringMUSenglish\@numberstringMenglish
\let\@numberstringFUSenglish\@numberstringMenglish
\let\@numberstringNUSenglish\@numberstringMenglish
\let\@NumberstringMUSenglish\@NumberstringMenglish
\let\@NumberstringFUSenglish\@NumberstringMenglish
\let\@NumberstringNUSenglish\@NumberstringMenglish
\let\@ordinalstringMUSenglish\@ordinalstringMenglish
\let\@ordinalstringFUSenglish\@ordinalstringMenglish
\let\@ordinalstringNUSenglish\@ordinalstringMenglish
\let\@OrdinalstringMUSenglish\@OrdinalstringMenglish
\let\@OrdinalstringFUSenglish\@OrdinalstringMenglish
\let\@OrdinalstringNUSenglish\@OrdinalstringMenglish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-USenglish.def>
%    \end{macrocode}
%\fi
%\Finale
\endinput
